<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ³•å¾‹æ–‡ä»¶è„±æ•å¤„ç†å·¥å…·</title>
    <script src="mammoth.browser.min.js"></script>
    <script src="jszip.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif; background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); overflow: hidden; }
        .header { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); color: white; padding: 30px; text-align: center; }
        .header h1 { font-size: 28px; margin-bottom: 10px; }
        .content { padding: 30px; }
        .upload-area { border: 3px dashed #1e3c72; border-radius: 12px; padding: 40px; text-align: center; cursor: pointer; background: #f0f4ff; transition: all 0.3s; }
        .upload-area:hover { border-color: #2a5298; background: #e8f0ff; }
        .upload-area.dragover { background: #d8e8ff; transform: scale(1.02); }
        #fileInput { display: none; }
        .btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 15px; cursor: pointer; margin: 5px; font-weight: 500; }
        .btn-primary { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-secondary { background: #e8f0ff; color: #1e3c72; }
        .action-bar { display: flex; justify-content: center; gap: 15px; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; }
        .stats { display: flex; gap: 20px; margin-top: 20px; padding: 15px; background: #f8f9ff; border-radius: 8px; }
        .stat-item { text-align: center; }
        .stat-value { font-size: 24px; font-weight: bold; color: #1e3c72; }
        .stat-label { font-size: 12px; color: #888; }
        .panel-container { display: grid; grid-template-columns: 1fr 350px 1fr; gap: 20px; margin-top: 25px; height: 550px; }
        .panel { border: 1px solid #ddd; border-radius: 8px; overflow: hidden; display: flex; flex-direction: column; }
        .panel-header { background: #f8f9fa; padding: 15px; border-bottom: 1px solid #ddd; font-weight: 600; display: flex; justify-content: space-between; align-items: center; }
        .panel-content { flex: 1; overflow-y: auto; padding: 15px; background: white; }
        .preview-text { line-height: 1.8; color: #333; white-space: pre-wrap; }
        .redacted { background-color: #fff3cd; border-radius: 3px; padding: 2px 4px; cursor: pointer; transition: background-color 0.2s; }
        .redacted:hover { background-color: #ffe69c; }
        .redacted-preview { background-color: #fff3cd; padding: 2px 4px; border-radius: 3px; }
        @keyframes orange-flash {
            0%, 100% { background-color: #fff3cd; }
            50% { background-color: #ff9800; }
        }
        .orange-flash { animation: orange-flash 0.6s ease-in-out 3; }
        .redaction-item { background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 12px; margin-bottom: 10px; font-size: 13px; }
        .redaction-original { color: #dc3545; word-break: break-all; }
        .redaction-replacement { color: #28a745; font-weight: 500; word-break: break-all; }
        .redaction-location { font-size: 11px; color: #6c757d; margin-top: 4px; }
        .redaction-actions { display: flex; gap: 5px; margin-top: 8px; }
        .btn-xs { padding: 4px 8px; font-size: 11px; border-radius: 4px; border: none; cursor: pointer; }
        .type-organization { background: #d4edda; color: #155724; }
        .type-date { background: #cce5ff; color: #004085; }
        .type-price { background: #f8d7da; color: #721c24; }
        .type-person_name { background: #d1ecf1; color: #0c5460; }
        .type-credit_code { background: #e2e3e5; color: #383d41; }
        .type-org_code { background: #d6d8db; color: #383d41; }
        .type-patent_code { background: #cfd2d6; color: #383d41; }
        .type-file_code { background: #dee2e6; color: #383d41; }
        .type-project_name { background: #fff3cd; color: #856404; }
        .type-phone { background: #e0cffc; color: #6f42c1; }
        .type-email { background: #d4edda; color: #155724; }
        .type-address { background: #f0e68c; color: #856404; }
        .type-id_card { background: #ffd6e8; color: #c2185b; }
        .hidden { display: none !important; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; }
        .modal.show { display: flex; justify-content: center; align-items: center; }
        .modal-content { background: white; border-radius: 12px; padding: 30px; min-width: 400px; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: 500; }
        .form-control { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; }
        .type-selector { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .type-option { padding: 10px; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; text-align: center; }
        .type-option:hover { background: #f0f4ff; }
        .type-option.selected { background: #1e3c72; color: white; }
        .mode-selector { display: flex; gap: 20px; justify-content: center; margin: 30px 0; }
        .mode-card { flex: 1; max-width: 300px; padding: 30px; border: 2px solid #e9ecef; border-radius: 12px; text-align: center; cursor: pointer; transition: all 0.3s; }
        .mode-card:hover { border-color: #1e3c72; transform: translateY(-4px); box-shadow: 0 8px 25px rgba(30,60,114,0.15); }
        .mode-card.selected { border-color: #1e3c72; background: #f0f4ff; }
        .mode-icon { font-size: 48px; margin-bottom: 15px; }
        .mode-title { font-size: 18px; font-weight: 600; color: #1e3c72; margin-bottom: 8px; }
        .mode-desc { font-size: 13px; color: #6c757d; }
        /* è‡ªå®šä¹‰è„±æ•ç±»å‹æ ·å¼ */
        .btn-add-type { grid-column: 1/-1; padding: 15px; border: 2px dashed #28a745; background: #f8f9fa; border-radius: 8px; cursor: pointer; font-size: 14px; color: #28a745; transition: all 0.3s; }
        .btn-add-type:hover { background: #28a745; color: white; }

        .custom-types-list { max-height: 350px; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; padding: 10px; }

        .custom-type-item { padding: 10px; border: 1px solid #e9ecef; border-radius: 6px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s; }
        .custom-type-item:hover { background: #f0f4ff; border-color: #28a745; }

        .type-item-header { display: flex; justify-content: space-between; align-items: center; }

        .type-name { font-weight: 500; flex: 1; }

        .item-count { font-size: 12px; color: #999; }

        .type-editor-area { border: 1px solid #ddd; border-radius: 6px; padding: 15px; background: #fafafa; min-height: 300px; }

        .type-items-list { max-height: 200px; overflow-y: auto; margin-top: 10px; }

        .type-item-row { display: flex; justify-content: space-between; align-items: center; padding: 8px; background: white; border: 1px solid #e9ecef; border-radius: 4px; margin-bottom: 5px; }

        .item-text { flex: 1; word-break: break-all; }

        .btn-mini { padding: 2px 6px; font-size: 12px; border-radius: 3px; border: none; cursor: pointer; }
        .btn-mini.btn-danger { background: #dc3545; color: white; }
        .btn-mini.btn-danger:hover { background: #c82333; }
        .type-group-title { grid-column: 1/-1; padding: 8px 12px; font-weight: 600; color: #1e3c72; font-size: 13px; text-align: center; background: #f0f4ff; border-radius: 4px; margin: 5px 0; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>æ³•å¾‹æ–‡ä»¶è„±æ•/è¿˜åŸå·¥å…·</h1>
            <p>è‡ªåŠ¨è¯†åˆ«æ•æ„Ÿä¿¡æ¯è¿›è¡Œè„±æ•ï¼Œæˆ–å°†è„±æ•ç¨¿è¿˜åŸä¸ºåŸæ–‡</p>
        </div>
        <div class="content">
            <!-- æ¨¡å¼é€‰æ‹©ç•Œé¢ -->
            <div id="modeSelector">
                <div class="mode-selector">
                    <div class="mode-card" onclick="app.selectMode('redact')" id="redactModeCard">
                        <div class="mode-icon">ğŸ“„</div>
                        <div class="mode-title">è„±æ•æ¨¡å¼</div>
                        <div class="mode-desc">ä¸Šä¼ åŸæ–‡ä»¶ï¼Œè‡ªåŠ¨è¯†åˆ«æ•æ„Ÿä¿¡æ¯å¹¶è„±æ•</div>
                    </div>
                    <div class="mode-card" onclick="app.selectMode('restore')" id="restoreModeCard">
                        <div class="mode-icon">ğŸ”“</div>
                        <div class="mode-title">è¿˜åŸæ¨¡å¼</div>
                        <div class="mode-desc">ä¸Šä¼ è„±æ•ç¨¿å’Œæ¯”å¯¹è¯ï¼Œè¿˜åŸä¸ºåŸæ–‡</div>
                    </div>
                </div>
            </div>

            <!-- è„±æ•æ¨¡å¼ç•Œé¢ -->
            <div id="redactModeUI" class="hidden">
                <div class="upload-area" id="uploadArea">
                    <div style="font-size: 48px;">ğŸ“</div>
                    <div style="font-size: 16px; margin-top: 10px;">ç‚¹å‡»é€‰æ‹©æˆ–æ‹–æ‹½docxæ–‡ä»¶åˆ°æ­¤å¤„</div>
                </div>
                <input type="file" id="fileInput" accept=".docx">

                <div id="mainContent" class="hidden">
                    <div class="action-bar">
                        <button class="btn btn-primary" onclick="app.identifyRedactions()">ğŸ”„ é‡æ–°è¯†åˆ«</button>
                        <button class="btn btn-secondary" onclick="app.showAddModal()">â• æ‰‹åŠ¨æ·»åŠ </button>
                        <button class="btn btn-success" onclick="app.showExportModal()">ğŸ“¥ å¯¼å‡ºç»“æœ</button>
                        <button class="btn btn-secondary" onclick="app.showListModal()">ğŸ“‹ ç™½åå•/é»‘åå•</button>
                        <button class="btn btn-danger" onclick="app.reset()">ğŸ—‘ï¸ é‡ç½®</button>
                        <label style="margin-left:15px;display:inline-flex;align-items:center;cursor:pointer;">
                            <input type="checkbox" id="debugMode" onchange="app.toggleDebug()">
                            <span style="margin-left:5px;">ğŸ› å¯ç”¨è°ƒè¯•æ¨¡å¼</span>
                        </label>
                    </div>

                    <div class="stats">
                        <div class="stat-item"><div class="stat-value" id="totalCount">0</div><div class="stat-label">è„±æ•é¡¹æ€»æ•°</div></div>
                        <div class="stat-item"><div class="stat-value" id="paragraphCount">0</div><div class="stat-label">æ®µè½æ•°</div></div>
                    </div>

                    <div id="debugPanel" class="hidden" style="background:#f8f9fa;padding:15px;margin:15px 0;border:1px solid #ddd;border-radius:8px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                            <h4 style="margin:0;">ğŸ› è°ƒè¯•æ—¥å¿—</h4>
                            <button class="btn btn-secondary" style="padding:5px 10px;font-size:12px;" onclick="app.exportDebugLog()">ğŸ“¥ å¯¼å‡ºæ—¥å¿—</button>
                        </div>
                        <div id="debugLog" style="font-family:monospace;font-size:12px;max-height:400px;overflow-y:auto;background:white;padding:10px;border:1px solid #eee;white-space:pre-wrap;"></div>
                    </div>

                    <div class="panel-container">
                        <div class="panel">
                            <div class="panel-header"><span>ğŸ“„ åŸæ–‡é¢„è§ˆ</span><small style="color:#6c757d;">é»„è‰²é«˜äº®ä¸ºå·²è¯†åˆ«å†…å®¹</small></div>
                            <div class="panel-content" id="originalPreview"></div>
                        </div>
                        <div class="panel">
                            <div class="panel-header"><span>ğŸ“‹ è„±æ•é¡¹åˆ—è¡¨</span><small id="redactionCount" style="color:#6c757d;">0 é¡¹</small></div>
                            <div class="panel-content" id="redactionList"></div>
                        </div>
                        <div class="panel">
                            <div class="panel-header"><span>ğŸ”’ è„±æ•é¢„è§ˆ</span><small style="color:#6c757d;">æ›¿æ¢åçš„æ•ˆæœ</small></div>
                            <div class="panel-content" id="redactedPreview"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- è¿˜åŸæ¨¡å¼ç•Œé¢ -->
            <div id="restoreModeUI" class="hidden">
                <div class="upload-area" id="restoreUploadArea" style="margin-bottom: 20px;">
                    <div style="font-size: 48px;">ğŸ“</div>
                    <div style="font-size: 16px; margin-top: 10px;">ä¸Šä¼ è„±æ•ç¨¿ï¼ˆå®¡æ ¸ç‰ˆï¼‰docxæ–‡ä»¶</div>
                </div>
                <input type="file" id="restoreFileInput" accept=".docx">

                <div class="upload-area" id="mappingUploadArea" style="margin-bottom: 20px;">
                    <div style="font-size: 48px;">ğŸ“„</div>
                    <div style="font-size: 16px; margin-top: 10px;">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ æ¯”å¯¹.mdæ–‡ä»¶</div>
                </div>
                <input type="file" id="mappingFileInput" accept=".md,.txt">

                <div class="action-bar">
                    <button class="btn btn-primary" onclick="restoreApp.executeRestore()">ğŸ”„ æ‰§è¡Œè¿˜åŸ</button>
                    <button class="btn btn-secondary" onclick="exportDebugLogs()">ğŸ“¥ å¯¼å‡ºè°ƒè¯•æ—¥å¿—</button>
                    <button class="btn btn-secondary" onclick="app.reset()">ğŸ”™ è¿”å›</button>
                </div>

                <div id="restoreResult" class="hidden" style="margin-top: 20px;">
                    <div class="stats">
                        <div class="stat-item"><div class="stat-value" id="restoreCount">0</div><div class="stat-label">è¿˜åŸé¡¹æ•°</div></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="addModal">
        <div class="modal-content">
            <h3 style="margin-bottom:20px;">æ‰‹åŠ¨æ·»åŠ è„±æ•é¡¹</h3>
            <div class="form-group">
                <label>åŸæ–‡å†…å®¹</label>
                <input type="text" class="form-control" id="manualOriginal" placeholder="è¾“å…¥è¦è„±æ•çš„æ–‡æœ¬">
            </div>
            <div class="form-group">
                <label>è„±æ•ç±»å‹</label>
                <div class="type-selector" id="typeSelector">
                    <div class="type-group-title">é»˜è®¤ç±»å‹</div>
                    <div class="type-option" data-type="id_card">èº«ä»½è¯å·</div>
                    <div class="type-option" data-type="organization">ç»„ç»‡æœºæ„</div>
                    <div class="type-option" data-type="date">æ—¥æœŸ</div>
                    <div class="type-option" data-type="price">ä»·æ ¼/é‡‘é¢</div>
                    <div class="type-option" data-type="person_name">äººå</div>
                    <div class="type-option" data-type="phone">è”ç³»ç”µè¯</div>
                    <div class="type-option" data-type="email">è”ç³»é‚®ç®±</div>
                    <div class="type-option" data-type="credit_code">ä»£ç </div>
                    <div class="type-option" data-type="project_name">é¡¹ç›®åç§°</div>
                    <div class="type-option" data-type="address">åœ°å€</div>
                    <div class="type-option" data-type="sensitive">æ•æ„Ÿä¿¡æ¯</div>
                    <div class="type-group-title">è‡ªå®šä¹‰ç±»å‹</div>
                    <button class="btn-add-type" onclick="app.showCustomTypeModal()">â• æ·»åŠ è„±æ•ç±»å‹</button>
                </div>
            </div>
            <div style="text-align:right; margin-top:20px;">
                <button class="btn btn-secondary" onclick="app.hideAddModal()">å–æ¶ˆ</button>
                <button class="btn btn-primary" onclick="app.addManualRedaction()">æ·»åŠ </button>
            </div>
        </div>
    </div>

    <div class="modal" id="exportModal">
        <div class="modal-content">
            <h3 style="margin-bottom:20px;">å¯¼å‡ºç»“æœ</h3>
            <p>è¯·é€‰æ‹©è¦å¯¼å‡ºçš„å†…å®¹ï¼š</p>
            <div style="margin-top:15px;">
                <label style="display:block; margin-bottom:10px;"><input type="checkbox" id="exportDocx" checked> ğŸ“„ è„±æ•æ–‡ä»¶.docx</label>
                <label style="display:block; margin-bottom:10px;"><input type="checkbox" id="exportMapping" checked> æ›¿æ¢æ¯”å¯¹.mdï¼ˆç”¨äºè¿˜åŸï¼‰</label>
            </div>
            <div style="text-align:right; margin-top:20px;">
                <button class="btn btn-secondary" onclick="app.hideExportModal()">å–æ¶ˆ</button>
                <button class="btn btn-success" onclick="app.exportResults()">å¯¼å‡º</button>
            </div>
            </div>
        </div>
    </div>

    <!-- ç™½åå•/é»‘åå•ç®¡ç†çª—å£ -->
    <div class="modal" id="listModal">
        <div class="modal-content" style="max-width:800px;">
            <h3 style="margin-bottom:20px;">ğŸ“‹ ç™½åå•/é»‘åå•ç®¡ç†</h3>

            <!-- å·¦å³ä¸¤åˆ—å¸ƒå±€ -->
            <div style="display:flex; gap:20px; flex-wrap:wrap;">
                <!-- å·¦ä¾§ï¼šç™½åå• -->
                <div style="flex:1; min-width:300px;">
                    <h4 style="color:#28a745; margin-bottom:10px;">ğŸŸ¢ ç™½åå• (ä¸è„±æ•)</h4>
                    <div id="whitelistContainer" style="max-height:300px; overflow-y:auto; border:1px solid #ddd; padding:10px; border-radius:4px; margin-bottom:10px; background:#fafafa;">
                        <p style="color:#999; text-align:center;" id="whitelistEmpty">æš‚æ— ç™½åå•é¡¹</p>
                    </div>
                    <div style="display:flex; gap:10px;">
                        <input type="text" id="whitelistInput" placeholder="è¾“å…¥å†…å®¹æ·»åŠ åˆ°ç™½åå•" style="flex:1; padding:8px; border:1px solid #ddd; border-radius:4px;">
                        <button class="btn btn-secondary" onclick="app.addToWhitelistFromUI()">æ·»åŠ </button>
                    </div>
                </div>

                <!-- å³ä¾§ï¼šé»‘åå• -->
                <div style="flex:1; min-width:300px;">
                    <h4 style="color:#dc3545; margin-bottom:10px;">âš« é»‘åå• (å¼ºåˆ¶è„±æ•)</h4>
                    <div id="blacklistContainer" style="max-height:300px; overflow-y:auto; border:1px solid #ddd; padding:10px; border-radius:4px; margin-bottom:10px; background:#fafafa;">
                        <p style="color:#999; text-align:center;" id="blacklistEmpty">æš‚æ— é»‘åå•é¡¹</p>
                    </div>
                    <div style="display:flex; gap:10px;">
                        <input type="text" id="blacklistInput" placeholder="è¾“å…¥å†…å®¹æ·»åŠ åˆ°é»‘åå•" style="flex:1; padding:8px; border:1px solid #ddd; border-radius:4px;">
                        <button class="btn btn-secondary" onclick="app.addToBlacklistFromUI()">æ·»åŠ </button>
                    </div>
                </div>
            </div>

            <div style="text-align:right; margin-top:20px; border-top:1px solid #ddd; padding-top:15px;">
                <button class="btn btn-secondary" onclick="app.closeListModal()">å…³é—­</button>
                <button class="btn btn-success" onclick="app.saveAndCloseListModal()">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <!-- è‡ªå®šä¹‰è„±æ•ç±»å‹ç®¡ç†æ¨¡æ€æ¡† -->
    <div class="modal" id="customTypeModal">
        <div class="modal-content" style="max-width:900px;">
            <h3 style="margin-bottom:20px;">ğŸ“ è‡ªå®šä¹‰è„±æ•ç±»å‹ç®¡ç†</h3>
            <p style="color:#6c757d; margin-bottom:15px;">åˆ›å»ºè‡ªå®šä¹‰è„±æ•ç±»å‹ï¼Œæ‰¹é‡è¾“å…¥ç²¾å‡†åŒ¹é…å†…å®¹ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰</p>

            <div style="display:grid; grid-template-columns: 280px 1fr; gap:20px; height:500px;">
                <!-- å·¦ä¾§ï¼šç±»å‹åˆ—è¡¨ -->
                <div>
                    <h4 style="margin-bottom:10px;">æˆ‘çš„ç±»å‹</h4>
                    <div class="custom-types-list" id="customTypesList">
                        <p style="color:#999; text-align:center; padding:20px 0;">æš‚æ— è‡ªå®šä¹‰ç±»å‹<br>ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ </p>
                    </div>
                    <button class="btn btn-success" style="width:100%; margin-top:10px;" onclick="app.promptAddType()">
                        â• æ–°å»ºç±»å‹
                    </button>
                </div>

                <!-- å³ä¾§ï¼šç¼–è¾‘åŒºåŸŸ -->
                <div>
                    <div id="typeEditorArea" style="height:100%; display:flex; flex-direction:column; justify-content:center; align-items:center; color:#999;">
                        <div style="text-align:center;">
                            <div style="font-size:48px; margin-bottom:10px;">ğŸ“</div>
                            <p>â† é€‰æ‹©ä¸€ä¸ªç±»å‹å¼€å§‹ç¼–è¾‘</p>
                        </div>
                    </div>
                </div>
            </div>

            <div style="text-align:right; margin-top:20px; border-top:1px solid #ddd; padding-top:15px;">
                <button class="btn btn-secondary" onclick="app.hideCustomTypeModal()">å…³é—­</button>
            </div>
        </div>
    </div>

    <!-- å†²çªæç¤ºå¼¹çª— -->
    <div class="modal" id="conflictModal">
        <div class="modal-content" style="max-width:400px;">
            <h3>âš ï¸ æ£€æµ‹åˆ°å†…å®¹å†²çª</h3>
            <p style="color:#d9534f; margin:15px 0;" id="conflictMessage"></p>
            <p style="color:#666; font-size:14px;">è¯·å…ˆä»åŸæœ‰åˆ—è¡¨ä¸­åˆ é™¤è¯¥é¡¹åï¼Œå†æ·»åŠ åˆ°æ–°åˆ—è¡¨ã€‚</p>
            <div style="text-align:right; margin-top:20px;">
                <button class="btn btn-primary" onclick="app.closeConflictModal()">æˆ‘çŸ¥é“äº†</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== ç™½åå•/é»‘åå•ç®¡ç† ====================
        const LISTS = {
            whitelist: new Set(),  // ç™½åå•ï¼šä¸è„±æ•çš„å†…å®¹
            blacklist: new Set(),   // é»‘åå•ï¼šå¼ºåˆ¶è„±æ•çš„å†…å®¹ï¼ˆå­˜å‚¨æ ¼å¼: { original, type } å¯¹è±¡ï¼‰
            customTypes: new Map()  // è‡ªå®šä¹‰ç±»å‹ï¼šMap<typeName, Set<{original, id}>>
        };

        let currentEditingType = null;

        // ä» localStorage åŠ è½½
        function loadLists() {
            try {
                const whitelist = localStorage.getItem('redaction_whitelist');
                const blacklist = localStorage.getItem('redaction_blacklist');
                if (whitelist) LISTS.whitelist = new Set(JSON.parse(whitelist));
                if (blacklist) {
                    const data = JSON.parse(blacklist);
                    LISTS.blacklist = new Set(data.map(item => {
                        // å…¼å®¹æ—§æ ¼å¼ï¼šå­—ç¬¦ä¸²è½¬ä¸ºå¯¹è±¡
                        if (typeof item === 'string') {
                            return { original: item, type: 'blacklist' };
                        }
                        return item;
                    }));
                }
                console.log('ç™½åå•/é»‘åå•å·²åŠ è½½:', {
                    whitelist: [...LISTS.whitelist],
                    blacklist: [...LISTS.blacklist]
                });
            } catch (e) {
                console.error('åŠ è½½ç™½åå•/é»‘åå•å¤±è´¥:', e);
            }
        }

        // ä¿å­˜åˆ° localStorage
        function saveLists() {
            try {
                localStorage.setItem('redaction_whitelist', JSON.stringify([...LISTS.whitelist]));
                localStorage.setItem('redaction_blacklist', JSON.stringify([...LISTS.blacklist]));
                console.log('ç™½åå•/é»‘åå•å·²ä¿å­˜');
            } catch (e) {
                console.error('ä¿å­˜ç™½åå•/é»‘åå•å¤±è´¥:', e);
            }
        }

        // ==================== è‡ªå®šä¹‰è„±æ•ç±»å‹ç®¡ç† ====================
        // åŠ è½½è‡ªå®šä¹‰ç±»å‹
        var loadCustomTypes = function() {
            try {
                const data = localStorage.getItem('redaction_customTypes');
                if (data) {
                    const parsed = JSON.parse(data);
                    // å°†JSONå¯¹è±¡è½¬æ¢ä¸ºMapï¼Œä¿æŒåŸæœ‰é¡ºåº
                    // ä½¿ç”¨ forEach å’Œ.entries ç¡®ä¿éå†é¡ºåºä¸€è‡´
                    const entries = [];
                    Object.entries(parsed).forEach(([k, v]) => {
                        // å°†æ•°ç»„è½¬ä¸º Setï¼Œä¿æŒåŸæœ‰é¡ºåº
                        entries.push([k, new Set(v)]);
                    });
                    LISTS.customTypes = new Map(entries);
                }
                console.log('è‡ªå®šä¹‰ç±»å‹å·²åŠ è½½:', [...LISTS.customTypes.keys()]);
                // åˆå§‹åŒ–ç±»å‹é€‰æ‹©å™¨
                initTypeSelector();
            } catch (e) {
                console.error('åŠ è½½è‡ªå®šä¹‰ç±»å‹å¤±è´¥:', e);
            }
        };

        // ä¿å­˜è‡ªå®šä¹‰ç±»å‹
        var saveCustomTypes = function() {
            try {
                // å°†Mapè½¬æ¢ä¸ºJSONå¯¹è±¡ï¼ŒSetè½¬æ¢ä¸ºæ•°ç»„
                // ä½¿ç”¨ forEach å’Œ.entries ç¡®ä¿éå†é¡ºåºä¸€è‡´
                const obj = {};
                LISTS.customTypes.forEach((value, key) => {
                    // å°†Setè½¬ä¸ºæ•°ç»„ï¼Œä¿æŒåŸæœ‰é¡ºåº
                    const arr = [];
                    value.forEach(item => arr.push(item));
                    obj[key] = arr;
                });
                localStorage.setItem('redaction_customTypes', JSON.stringify(obj));
                console.log('è‡ªå®šä¹‰ç±»å‹å·²ä¿å­˜');
            } catch (e) {
                console.error('ä¿å­˜è‡ªå®šä¹‰ç±»å‹å¤±è´¥:', e);
            }
        };

        // åˆå§‹åŒ–ç±»å‹é€‰æ‹©å™¨ï¼ˆæ·»åŠ è‡ªå®šä¹‰ç±»å‹é€‰é¡¹ï¼‰
        var initTypeSelector = function() {
            const selector = document.getElementById('typeSelector');
            if (!selector) return;

            // ç§»é™¤æ—§çš„è‡ªå®šä¹‰ç±»å‹é€‰é¡¹
            const existingCustom = selector.querySelectorAll('.type-option[data-type^="custom-"]');
            existingCustom.forEach(el => el.remove());

            // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªå®šä¹‰ç±»å‹ï¼ˆåŒ…æ‹¬ç©ºçš„ç±»å‹ï¼‰
            // ç©ºç±»å‹ä¹Ÿåº”è¯¥ä¿ç•™ï¼Œåªæœ‰ç”¨æˆ·ä¸»åŠ¨åˆ é™¤æ—¶æ‰ç§»é™¤
            if (LISTS.customTypes.size === 0) return;

            // æ‰¾åˆ°"è‡ªå®šä¹‰ç±»å‹"åˆ†ç»„æ ‡é¢˜
            const customGroupTitle = selector.querySelector('.type-group-title:last-of-type');
            const insertAfterElement = customGroupTitle || selector.lastElementChild;

            // æ·»åŠ è‡ªå®šä¹‰ç±»å‹é€‰é¡¹
            const fragment = document.createDocumentFragment();
            [...LISTS.customTypes.keys()].forEach(typeName => {
                const div = document.createElement('div');
                div.className = 'type-option';
                div.dataset.type = 'custom-' + typeName;
                div.textContent = typeName;
                div.onclick = function() {
                    // ç§»é™¤å…¶ä»–é€‰ä¸­çŠ¶æ€
                    document.querySelectorAll('.type-option').forEach(el => el.classList.remove('selected'));
                    div.classList.add('selected');
                };
                fragment.appendChild(div);
            });

            if (insertAfterElement) {
                insertAfterElement.after(fragment);
            } else {
                selector.appendChild(fragment);
            }
        };

        // é¡µé¢åŠ è½½æ—¶åŠ è½½è‡ªå®šä¹‰ç±»å‹
        loadCustomTypes();

        // æ£€æŸ¥æ˜¯å¦åœ¨ç™½åå•ä¸­
        function isInWhitelist(value) {
            return LISTS.whitelist.has(value);
        }

        // æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•ä¸­
        function isInBlacklist(value) {
            return LISTS.blacklist.has(value);
        }

        // æ£€æŸ¥å†…å®¹æ˜¯å¦è¢«ç™½åå•ä¸­çš„ä»»ä½•é¡¹è¦†ç›–ï¼ˆç”¨äºä¼˜å…ˆçº§ï¼šç™½åå• > è„±æ•ç±»åˆ«ï¼‰
        function isCoveredByWhitelist(content) {
            for (const whitelistItem of LISTS.whitelist) {
                // å¦‚æœè„±æ•å†…å®¹åŒ…å«ç™½åå•é¡¹ï¼Œæˆ–ç™½åå•é¡¹åŒ…å«è„±æ•å†…å®¹ï¼Œåˆ™è¢«è¦†ç›–
                if (content.includes(whitelistItem) || whitelistItem.includes(content)) {
                    return true;
                }
            }
            return false;
        }

        // æ·»åŠ åˆ°ç™½åå•
        function addToWhitelist(value, forceMove = false) {
            // å¦‚æœæ˜¯è¿ç§»æ¨¡å¼ï¼Œå…ˆä»å…¶ä»–åˆ—è¡¨ä¸­åˆ é™¤
            if (forceMove) {
                // ä»é»‘åå•åˆ é™¤
                const blacklistItem = [...LISTS.blacklist].find(item =>
                    (typeof item === 'string' ? item : item.original) === value
                );
                if (blacklistItem) {
                    LISTS.blacklist.delete(blacklistItem);
                    saveLists();
                }

                // ä»æ‰€æœ‰è‡ªå®šä¹‰ç±»å‹ä¸­åˆ é™¤æŒ‡å®šé¡¹
                // åªæœ‰å½“ç±»å‹å˜ä¸ºç©ºæ—¶æ‰åˆ é™¤æ•´ä¸ªç±»å‹ï¼Œå¦åˆ™åªæ›´æ–°ç±»å‹
                for (const [typeName, items] of LISTS.customTypes) {
                    const item = [...items].find(i => i.original === value);
                    if (item) {
                        items.delete(item);
                    }
                }
                // ç»Ÿä¸€æ›´æ–° Mapï¼ˆä¿ç•™ç©ºç±»å‹ï¼Œåªåˆ é™¤éç©ºçš„ï¼‰
                LISTS.customTypes.forEach((items, typeName) => {
                    if (items.size === 0) {
                        LISTS.customTypes.delete(typeName);
                    } else {
                        LISTS.customTypes.set(typeName, items);
                    }
                });
                saveCustomTypes();
            }

            // æ­£å¸¸æ·»åŠ ï¼ˆæ­¤æ—¶åŸåˆ—è¡¨å·²æ¸…ç†ï¼Œä¸ä¼šå†²çªï¼‰
            LISTS.whitelist.add(value);
            saveLists();
        }

        // ä»ç™½åå•ç§»é™¤
        function removeFromWhitelist(value) {
            LISTS.whitelist.delete(value);
            saveLists();
        }

        // æ·»åŠ åˆ°é»‘åå•
        function addToBlacklist(value, type = 'blacklist') {
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆåªæ¯”è¾ƒ originalï¼‰
            const existing = [...LISTS.blacklist].find(item =>
                (typeof item === 'string' ? item : item.original) === value
            );
            if (existing) {
                // æ›´æ–°ç±»å‹ï¼šåˆ é™¤æ—§è®°å½•
                LISTS.blacklist.delete(existing);
            }
            LISTS.blacklist.add({ original: value, type });
            saveLists();
        }

        // ä»é»‘åå•ç§»é™¤
        function removeFromBlacklist(value) {
            const existing = [...LISTS.blacklist].find(item =>
                (typeof item === 'string' ? item : item.original) === value
            );
            if (existing) {
                LISTS.blacklist.delete(existing);
                saveLists();
            }
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–ç™½åå•/é»‘åå•
        loadLists();

        // ==================== è„±æ•è§„åˆ™å®šä¹‰ ====================
        const DEFAULT_RULES = {
            rules: [
                { category: "email", patterns: ["[\\w\\-\\.]+@[\\w\\-]+(?:\\.[\\w\\-]+)+", "é‚®ç®±\\s*[ï¼š:]?\\s*([\\w\\-\\.]+@[\\w\\-]+(?:\\.[\\w\\-]+)+)"], replacement: "ã€é‚®ç®±${index}ã€‘", useCaptureGroup: true },
                { category: "id_card", patterns: ["[1-9]\\d{5}(18|19|20)\\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])\\d{3}[0-9Xx]"], replacement: "ã€èº«ä»½è¯å·${index}ã€‘" },
                { category: "organization", patterns: ["([\\u4e00-\\u9fa5]{2,20})(æœ‰é™å…¬å¸|è‚¡ä»½å…¬å¸|é›†å›¢)", "([A-Za-z][A-Za-z0-9\\s&]{2,30})(?:Company|Co\\.|Corporation|Corp\\.|Ltd\\.|Limited|LLC|Inc\\.|GmbH|S\\.A\\.|S\\.A|Sp\\. z o\\.o\\.|K\\.K\\.)\\b", "([\\u4e00-\\u9fa5]{2,10})(?:æœ‰é™è´£ä»»å…¬å¸|è‚¡ä»½æœ‰é™å…¬å¸)"], replacement: "ã€å…¬å¸${index}ã€‘" },
                { category: "date", patterns: ["\\d{4}\\s{0,2}å¹´\\s{0,2}\\d{1,2}\\s{0,2}æœˆ\\s{0,2}\\d{1,2}\\s{0,2}æ—¥", "\\d{4}-\\d{1,2}-\\d{1,2}", "\\d{4}/\\d{1,2}/\\d{1,2}", "\\d{1,2}æœˆ\\d{1,2}æ—¥"], replacement: "ã€æ—¥æœŸ${index}ã€‘" },
                { category: "price", patterns: ["äººæ°‘å¸\\s*(\\d+(?:,\\d{3})*(?:\\.\\d+)?)\\s*[å…ƒä¸‡å…ƒ]", "ï¿¥\\s*(\\d+(?:,\\d{3})*(?:\\.\\d+)?)\\s*å…ƒ", "\\d+(?:,\\d{3})*(?:\\.\\d+)?[ä¸‡åƒä¸‡å…ƒ]", "(?:äººæ°‘å¸|ï¿¥)\\s*([å£¹è´°åè‚†ä¼é™†æŸ’æŒç–é›¶æ‹¾ä½°ä»Ÿä¸‡äº¿åƒç™¾å]+å…ƒæ•´?)", "(?:äººæ°‘å¸|ï¿¥)\\s*([å£¹è´°åè‚†ä¼é™†æŸ’æŒç–é›¶æ‹¾ä½°ä»Ÿä¸‡äº¿åƒç™¾å]+[è§’åˆ†])", "[å£¹è´°åè‚†ä¼é™†æŸ’æŒç–é›¶æ‹¾ä½°ä»Ÿä¸‡äº¿åƒç™¾å]+å…ƒæ•´?", "[å£¹è´°åè‚†ä¼é™†æŸ’æŒç–é›¶æ‹¾ä½°ä»Ÿä¸‡äº¿åƒç™¾å]+[è§’åˆ†]", "(?:RMB|USD|CNY|HKD|JPY|EUR|GBP)\\s+(\\d+(?:,\\d{3})*(?:\\.\\d+)?)", "(\\d+(?:,\\d{3})*(?:\\.\\d+)?)\\s*[ï½\\-ï¼è‡³]\\s*(\\d+(?:,\\d{3})*(?:\\.\\d+)?)", "(?:RMB|USD|CNY|HKD|JPY|EUR|GBP)\\s+\\d+(?:,\\d{3})*(?:\\.\\d+)?\\s*[ï½\\-ï¼è‡³]\\s*(\\d+(?:,\\d{3})*(?:\\.\\d+)?)"], replacement: "ã€é‡‘é¢${index}ã€‘", useCaptureGroup: true },
                { category: "person_name", patterns: ["(?:ç”²æ–¹|ä¹™æ–¹|ä¸™æ–¹|ä¸æ–¹|æˆŠæ–¹|å·±æ–¹|åŸå‘Šæ–¹|è¢«å‘Šæ–¹|å§”æ‰˜æ–¹|å—æ‰˜æ–¹|å‘åŒ…æ–¹|æ‰¿åŒ…æ–¹|é‡‡è´­æ–¹|ä¾›åº”å•†|å–æ–¹|ä¹°æ–¹|å‡ºç§Ÿæ–¹|æ‰¿ç§Ÿæ–¹|è½¬è®©æ–¹|å—è®©æ–¹|æŠ•èµ„æ–¹|è¢«æŠ•èµ„æ–¹|å€Ÿæ¬¾äºº|è´·æ¬¾äºº|ä¿è¯äºº|æŠµæŠ¼äºº|å‡ºè´¨äºº|æ”¶æ¬¾äºº|ä»˜æ¬¾äºº|å€ºåŠ¡äºº|å€ºæƒäºº|ç”³è¯·äºº|è¢«ç”³è¯·äºº|æ³•å®šä»£è¡¨äºº|è”ç³»äºº)\\s*[ï¼š:]\\s*([\\u4e00-\\u9fa5]{2,20})"], replacement: "ã€äººå‘˜${index}ã€‘", useCaptureGroup: true },
                { category: "phone", patterns: ["è”ç³»ç”µè¯\\s*[ï¼š:]\\s*(1[3-9]\\d{9})", "è”ç³»ç”µè¯\\s*[ï¼š:]\\s*(0\\d{2,3}-?\\d{7,8})", "è”ç³»ç”µè¯\\s*[ï¼š:]\\s*\\((0\\d{2,3})\\)\\d{7,8}", "ç”µè¯\\s*[ï¼š:]\\s*(1[3-9]\\d{9})", "ç”µè¯\\s*[ï¼š:]\\s*(0\\d{2,3}-?\\d{7,8})", "æ‰‹æœº\\s*[ï¼š:]\\s*(1[3-9]\\d{9})"], useCaptureGroup: true, replacement: "ã€ç”µè¯${index}ã€‘" },
                { category: "credit_code", patterns: ["ç»Ÿä¸€ç¤¾ä¼šä¿¡ç”¨ä»£ç \\s*[ï¼š:]\\s*([0-9A-HJ-NPQRTUWXY]{15,18})", "ç»Ÿä¸€ç¤¾ä¼šä¿¡ç”¨ä»£ç \\s*[ï¼š:]\\s*([0-9a-hj-npqrtuwxy]{15,18})"], useCaptureGroup: true, replacement: "ã€ä»£ç -ç»Ÿä¸€ç¤¾ä¼šä¿¡ç”¨ä»£ç ${index}ã€‘" },
                { category: "bank_account", patterns: ["è´¦å·\\s*[ï¼š:]\\s*(\\d{16,19})", "é“¶è¡Œè´¦å·\\s*[ï¼š:]\\s*(\\d{16,19})", "è´¦æˆ·\\s*[ï¼š:]\\s*(\\d{16,19})", "\\d{4}\\s+\\d{4}\\s+\\d{4}\\s+\\d{4}(?:\\s+\\d{4})?"], replacement: "ã€è´¦å·${index}ã€‘", useCaptureGroup: true },
                { category: "org_code", patterns: ["ç»„ç»‡æœºæ„ä»£ç \\s*[ï¼š:]\\s*(\\d{8}-?[0-9X])"], useCaptureGroup: true, replacement: "ã€ä»£ç -ç»„ç»‡æœºæ„ä»£ç ${index}ã€‘" },
                { category: "patent_code", patterns: ["(?:ä¸“åˆ©|å•†æ ‡|è‘—ä½œæƒ)ç”³è¯·å·\\s*[ï¼š:]\\s*([A-Z0-9\\.]+)", "(?:JP|US|EP|CN|WO|KR|GB|DE|FR|CA|AU)(?:\\d{4,}|\\d{4}/\\d{6})[A-Z]\\d?", "[A-Z]{2}\\d{6,}[A-Z]{0,2}\\d?"], useCaptureGroup: true, replacement: "ã€ä»£ç -ä¸“åˆ©ç”³è¯·å·${index}ã€‘" },
                { category: "file_code", patterns: ["åˆåŒç¼–å·\\s*[ï¼š:]\\s*([A-Z0-9\\-]+)", "æ–‡ä»¶ç¼–å·\\s*[ï¼š:]\\s*([A-Z0-9\\-]+)", "æ–‡ä»¶å·\\s*[ï¼š:]\\s*([A-Z0-9\\-]+)" ], useCaptureGroup: true, replacement: "ã€ä»£ç -æ–‡ä»¶ç¼–å·${index}ã€‘" },
                { category: "case_number", patterns: ["([ï¼ˆ(]\\d{4}[)ï¼‰][^æ°‘åˆ‘è¡ŒçŸ¥èµ”]{1,6}?(?:æ°‘|åˆ‘|è¡Œ|çŸ¥|èµ”)[^åˆç»ˆå†ç›‘æ‰§å­—ç¬¬]{0,5}?\\d+[å·])(?:[ï¼Œã€‚ã€,;ï¼.ï¼Ÿ])?", "(\\(\\d{4}\\)[^\"]{2,8}?\\d+å·)(?:[ï¼Œã€‚ã€,;ï¼.ï¼Ÿ])?", "(ï¼ˆ\\d{4}ï¼‰[^\"]{2,8}?\\d+å·)(?:[ï¼Œã€‚ã€,;ï¼.ï¼Ÿ])?", "(\\d{4}å¹´ï¼ˆ[A-Z]{1,5}ï¼‰ç¬¬\\d+å·)(?:[ï¼Œã€‚ã€,;ï¼.ï¼Ÿ])?", "(Case No\\.(?:\\s+[\\d:]+-cv-)?\\d+)(?:[ï¼Œã€‚ã€,;ï¼.ï¼Ÿ])?", "((?:Civil Action) No\\.\\s+[\\d:]+-cv-\\d+)(?:[ï¼Œã€‚ã€,;ï¼.ï¼Ÿ])?", "(\\[\\d{4}\\]\\s+[A-Z]{1,4}\\s+\\d+\\s+\\([A-Z]+\\))(?:[ï¼Œã€‚ã€,;ï¼.ï¼Ÿ])?", "(Az\\.:\\s+\\d+[A-Z]?\\s+\\d+/\\d{2,4})(?:[ï¼Œã€‚ã€,;ï¼.ï¼Ÿ])?", "(RG\\s+\\d+/\\d+)(?:[ï¼Œã€‚ã€,;ï¼.ï¼Ÿ])?"], useCaptureGroup: true, replacement: "ã€æ¡ˆå·${index}ã€‘" },
                { category: "project_name", patterns: ["(?<!ç”²æ–¹|ä¹™æ–¹|ä¸™æ–¹|ä¸æ–¹|ä¹°æ–¹|å–æ–¹|å§”æ‰˜æ–¹|å—æ‰˜æ–¹|å‘åŒ…æ–¹|æ‰¿åŒ…æ–¹|é‡‡è´­æ–¹|ä¾›åº”å•†)([\\u4e00-\\u9fa5]{2,10})(é¡¹ç›®|å·¥ç¨‹|ç³»ç»Ÿ|å¹³å°|è®¡åˆ’)", "([\\u4e00-\\u9fa5]{2,10})(ç ”å‘|å»ºè®¾|å®æ–½)é¡¹ç›®"], replacement: "ã€é¡¹ç›®${index}ã€‘" },
                { category: "address", patterns: ["(?:åœ°å€|ä½æ‰€|ä½å€|æ³¨å†Œåœ°å€|åŠå…¬åœ°å€|ä½æ‰€åœ°)\\s*[ï¼š:]\\s*([\\u4e00-\\u9fa5\\w\\d\\u3000]+)", "([\\u4e00-\\u9fa5]{2,4}å¸‚[\\u4e00-\\u9fa5]{1,4}åŒº[\\u4e00-\\u9fa5\\d]+(?:è·¯|è¡—|é“|å¤§é“)(?:\\d+|[\\u4e00-\\u9fa5]+)æ¥¼\\d{1,4}-\\d{1,4})"], useCaptureGroup: true, replacement: "ã€åœ°å€${index}ã€‘" },
                { category: "sensitive", patterns: [], replacement: "ã€æ•æ„Ÿä¿¡æ¯${index}ã€‘" }
            ]
        };

        const TYPE_NAMES = { id_card: "èº«ä»½è¯å·", organization: "ç»„ç»‡æœºæ„", date: "æ—¥æœŸ", price: "é‡‘é¢", person_name: "äººå", phone: "è”ç³»ç”µè¯", email: "è”ç³»é‚®ç®±", credit_code: "ä»£ç -ç»Ÿä¸€ç¤¾ä¼šä¿¡ç”¨ä»£ç ", bank_account: "è´¦å·", org_code: "ä»£ç -ç»„ç»‡æœºæ„ä»£ç ", patent_code: "ä»£ç -ä¸“åˆ©ç”³è¯·å·", file_code: "ä»£ç -æ–‡ä»¶ç¼–å·", case_number: "æ¡ˆå·", project_name: "é¡¹ç›®åç§°", address: "åœ°å€", blacklist: "é»‘åå•", sensitive: "æ•æ„Ÿä¿¡æ¯" };

        class RedactionApp {
            constructor() {
                this.file = null;
                this.document = null;
                this.redactions = [];
                this.typeCounters = {};
                this.lastClickedId = null;  // ä¸Šæ¬¡ç‚¹å‡»çš„è„±æ•é¡¹ID
                this.scrollDirection = 'up';  // å½“å‰æ»šåŠ¨æ–¹å‘
                this.debugMode = false;  // è°ƒè¯•æ¨¡å¼å¼€å…³
                this.initEvents();
            }

            initEvents() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                uploadArea.onclick = () => fileInput.click();
                uploadArea.ondragover = (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); };
                uploadArea.ondragleave = () => uploadArea.classList.remove('dragover');
                uploadArea.ondrop = (e) => { e.preventDefault(); uploadArea.classList.remove('dragover'); if(e.dataTransfer.files[0]) this.handleFile(e.dataTransfer.files[0]); };
                fileInput.onchange = (e) => { if(e.target.files[0]) this.handleFile(e.target.files[0]); };

                document.querySelectorAll('.type-option').forEach(el => {
                    el.onclick = () => {
                        document.querySelectorAll('.type-option').forEach(e => e.classList.remove('selected'));
                        el.classList.add('selected');
                    };
                });

                // ç›‘å¬åŸæ–‡é¢„è§ˆä¸­çš„æ–‡æœ¬é€‰æ‹©
                const originalPreview = document.getElementById('originalPreview');
                originalPreview.addEventListener('mouseup', () => this.handleTextSelection());
                originalPreview.addEventListener('keyup', () => this.handleTextSelection());
            }

            /**
             * ä½¿ç”¨ JSZip è§£æ docx æ–‡ä»¶ï¼Œæå–åŒ…å«è‡ªåŠ¨ç¼–å·çš„æ®µè½
             */
            async parseDocxWithNumbering(arrayBuffer) {
                const zip = await JSZip.loadAsync(arrayBuffer);
                const documentXml = await zip.file("word/document.xml").async("string");

                // å°è¯•è¯»å–ç¼–å·å®šä¹‰
                let numberingXml = null;
                const numberingFile = zip.file("word/numbering.xml");
                if (numberingFile) {
                    numberingXml = await numberingFile.async("string");
                }

                // è§£æç¼–å·å®šä¹‰
                const numberingMap = this.parseNumberingXml(numberingXml);

                // è§£ææ®µè½
                const parser = new DOMParser();
                const doc = parser.parseFromString(documentXml, "text/xml");
                const paragraphs = doc.getElementsByTagName("w:p");

                const result = [];

                // ç»´æŠ¤ç¼–å·è®¡æ•°å™¨
                const numCounters = {};

                for (let i = 0; i < paragraphs.length; i++) {
                    const p = paragraphs[i];

                    // æå–æ–‡æœ¬å†…å®¹
                    const textNodes = p.getElementsByTagName("w:t");
                    let text = "";
                    for (let j = 0; j < textNodes.length; j++) {
                        text += textNodes[j].textContent;
                    }
                    text = text.trim();
                    if (!text) continue;

                    // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªåŠ¨ç¼–å·
                    const numPr = p.getElementsByTagName("w:numPr")[0];
                    let prefix = "";

                    if (numPr) {
                        // è·å–ç¼–å·IDå’Œçº§åˆ«
                        const numIdElem = numPr.getElementsByTagName("w:numId")[0];
                        const ilvlElem = numPr.getElementsByTagName("w:ilvl")[0];

                        if (numIdElem) {
                            const numId = numIdElem.getAttribute("w:val");
                            const ilvl = ilvlElem ? parseInt(ilvlElem.getAttribute("w:val")) : 0;

                            // è·å–ç¼–å·å®šä¹‰
                            const numDef = numberingMap[numId];
                            if (numDef && numDef.levels) {
                                const levelDef = numDef.levels[ilvl] || numDef.levels[0];

                                // æ›´æ–°è®¡æ•°å™¨
                                const key = `${numId}-${ilvl}`;
                                if (!numCounters[key]) {
                                    numCounters[key] = levelDef.start || 1;
                                }

                                // ç”Ÿæˆç¼–å·æ–‡æœ¬
                                prefix = this.formatNumber(numCounters[key], levelDef.format, levelDef.text);
                                numCounters[key]++;
                            }
                        }
                    }

                    // æ‹¼æ¥ç¼–å·å’Œæ­£æ–‡ï¼ˆå¦‚æœæœ‰ç¼–å·åˆ™åŠ ç©ºæ ¼ï¼‰
                    result.push(prefix ? prefix + " " + text : text);
                }

                return result;
            }

            /**
             * è§£æ numbering.xmlï¼Œè¿”å›ç¼–å·å®šä¹‰æ˜ å°„
             */
            parseNumberingXml(numberingXml) {
                if (!numberingXml) return {};

                const parser = new DOMParser();
                const doc = parser.parseFromString(numberingXml, "text/xml");

                const map = {};

                // è§£ææŠ½è±¡ç¼–å·å®šä¹‰
                const abstractNums = {};
                const abstractNumElements = doc.getElementsByTagName("w:abstractNum");

                for (let i = 0; i < abstractNumElements.length; i++) {
                    const abstractNumId = abstractNumElements[i].getAttribute("w:abstractNumId");
                    const levels = {};

                    const lvlElements = abstractNumElements[i].getElementsByTagName("w:lvl");
                    for (let j = 0; j < lvlElements.length; j++) {
                        const ilvl = parseInt(lvlElements[j].getAttribute("w:ilvl"));

                        // è·å–ç¼–å·æ ¼å¼
                        const numFmtElem = lvlElements[j].getElementsByTagName("w:numFmt")[0];
                        const format = numFmtElem ? numFmtElem.getAttribute("w:val") : "decimal";

                        // è·å–ç¼–å·æ–‡æœ¬æ¨¡æ¿
                        const lvlTextElem = lvlElements[j].getElementsByTagName("w:lvlText")[0];
                        const text = lvlTextElem ? lvlTextElem.getAttribute("w:val") : "%1.";

                        // è·å–èµ·å§‹å€¼
                        const startElem = lvlElements[j].getElementsByTagName("w:start")[0];
                        const start = startElem ? parseInt(startElem.getAttribute("w:val")) : 1;

                        levels[ilvl] = { format, text, start };
                    }

                    abstractNums[abstractNumId] = { levels };
                }

                // è§£æç¼–å·å®ä¾‹
                const numElements = doc.getElementsByTagName("w:num");
                for (let i = 0; i < numElements.length; i++) {
                    const numId = numElements[i].getAttribute("w:numId");
                    const abstractNumIdElem = numElements[i].getElementsByTagName("w:abstractNumId")[0];

                    if (abstractNumIdElem) {
                        const abstractNumId = abstractNumIdElem.getAttribute("w:val");
                        map[numId] = abstractNums[abstractNumId] || { levels: {} };
                    }
                }

                return map;
            }

            /**
             * æ ¼å¼åŒ–ç¼–å·ï¼ˆå°†æ•°å­—è½¬æ¢ä¸ºæŒ‡å®šæ ¼å¼ï¼‰
             */
            formatNumber(num, format, template) {
                let formattedNum = String(num);

                // æ£€æµ‹ä¸­æ–‡æ ¼å¼ï¼ˆæ¨¡æ¿åŒ…å«ä¸­æ–‡å­—ç¬¦ï¼Œå¦‚"ç¬¬%1æ¡"ã€"ç¬¬%1æ¬¾"ï¼‰
                const isChineseFormat = /[\u4e00-\u9fa5]/.test(template);

                if (isChineseFormat) {
                    // ä¸­æ–‡æ ¼å¼ï¼Œä½¿ç”¨ä¸­æ–‡æ•°å­—
                    formattedNum = this.toChineseNum(num);
                } else {
                    // å…¶ä»–æ ¼å¼ï¼ˆç½—é©¬æ•°å­—ã€å­—æ¯ç­‰ï¼‰
                    switch (format) {
                        case "upperRoman":
                            formattedNum = this.toRoman(num);
                            break;
                        case "lowerRoman":
                            formattedNum = this.toRoman(num).toLowerCase();
                            break;
                        case "upperLetter":
                            formattedNum = String.fromCharCode(64 + num);
                            break;
                        case "lowerLetter":
                            formattedNum = String.fromCharCode(96 + num);
                            break;
                        case "decimal":
                        default:
                            // é»˜è®¤ä¸ºæ•°å­—
                            break;
                    }
                }

                // æ›¿æ¢æ¨¡æ¿ä¸­çš„å ä½ç¬¦
                return template
                    .replace("%1", formattedNum)
                    .replace("%2", formattedNum)
                    .replace("%3", formattedNum);
            }

            /**
             * æ•°å­—è½¬ç½—é©¬æ•°å­—
             */
            toRoman(num) {
                const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
                const literals = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];
                let result = "";
                for (let i = 0; i < values.length; i++) {
                    while (num >= values[i]) {
                        result += literals[i];
                        num -= values[i];
                    }
                }
                return result;
            }

            /**
             * æ•°å­—è½¬ä¸­æ–‡æ•°å­—ï¼ˆç”¨äºæ³•å¾‹æ¡æ–‡ç¼–å·ï¼‰
             * æ”¯æŒèŒƒå›´ï¼š1-100ï¼ˆæ³•å¾‹æ¡æ–‡é€šå¸¸ä¸è¶…è¿‡100æ¡ï¼‰
             */
            toChineseNum(num) {
                const digits = ['é›¶', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹'];
                const units = ['', 'å', 'ç™¾', 'åƒ'];

                if (num < 10) {
                    return digits[num];
                } else if (num < 20) {
                    // 11-19ï¼šåä¸€ã€åäºŒ...
                    return 'å' + (num % 10 === 0 ? '' : digits[num % 10]);
                } else if (num < 100) {
                    // 20-99ï¼šäºŒåã€äºŒåä¸€...
                    const tens = Math.floor(num / 10);
                    const ones = num % 10;
                    return digits[tens] + 'å' + (ones === 0 ? '' : digits[ones]);
                } else if (num === 100) {
                    return 'ä¸€ç™¾';
                } else {
                    // è¶…å‡ºèŒƒå›´ï¼Œè¿”å›é˜¿æ‹‰ä¼¯æ•°å­—
                    return String(num);
                }
            }

            async handleFile(file) {
                if (!file.name.endsWith('.docx')) { alert('è¯·ä¸Šä¼ .docxæ–‡ä»¶'); return; }
                this.file = file;
                const arrayBuffer = await file.arrayBuffer();

                // ä½¿ç”¨æ–°çš„è§£ææ–¹æ³•ï¼Œæ”¯æŒè‡ªåŠ¨ç¼–å·
                const processedParagraphs = await this.parseDocxWithNumbering(arrayBuffer);

                // === è°ƒè¯•è¾“å‡º ===
                console.log(`=== å¤„ç†åçš„æ®µè½ï¼ˆå…±${processedParagraphs.length}ä¸ªï¼Œæ˜¾ç¤ºå‰100ä¸ªï¼‰===`);
                processedParagraphs.slice(0, 100).forEach((text, i) => {
                    console.log(`[${i}] ${text.substring(0, 100)}`);
                });

                this.document = { paragraphs: processedParagraphs };
                this.identifyRedactions();
                this.render();
                document.getElementById('mainContent').classList.remove('hidden');
            }

            identifyRedactions() {
                // æ¸…ç©ºè°ƒè¯•æ—¥å¿—
                if (this.debugMode) {
                    const debugLogDiv = document.getElementById('debugLog');
                    if (debugLogDiv) debugLogDiv.textContent = '';
                    this.debugLog('=== å¼€å§‹è¯†åˆ« ===');
                    this.debugLog(`æ€»æ®µè½æ•°: ${this.document.paragraphs.length}`);
                    this.debugLog(`å…¨æ–‡é•¿åº¦: ${this.document.paragraphs.join('\n').length} å­—ç¬¦`);
                    this.debugLog('');
                }

                // é€šç”¨è¯æ’é™¤åˆ—è¡¨
                const EXCLUDED_TERMS = new Set([
                    'ç”²æ–¹', 'ä¹™æ–¹', 'ä¸™æ–¹', 'ä¸æ–¹', 'æˆŠæ–¹', 'å·±æ–¹',
                    'åŸå‘Šæ–¹', 'è¢«å‘Šæ–¹', 'å§”æ‰˜æ–¹', 'å—æ‰˜æ–¹', 'å‘åŒ…æ–¹', 'æ‰¿åŒ…æ–¹', 'é‡‡è´­æ–¹', 'ä¾›åº”å•†', 'å–æ–¹', 'ä¹°æ–¹',
                    'å‡ºç§Ÿæ–¹', 'æ‰¿ç§Ÿæ–¹', 'è½¬è®©æ–¹', 'å—è®©æ–¹', 'æŠ•èµ„æ–¹', 'è¢«æŠ•èµ„æ–¹', 'å€Ÿæ¬¾äºº', 'è´·æ¬¾äºº',
                    'ä¿è¯äºº', 'æŠµæŠ¼äºº', 'å‡ºè´¨äºº', 'æ”¶æ¬¾äºº', 'ä»˜æ¬¾äºº', 'å€ºåŠ¡äºº', 'å€ºæƒäºº',
                    'ç”³è¯·äºº', 'è¢«ç”³è¯·äºº',
                    'ç­¾ç½²æ—¶é—´', 'ç­¾ç½²æ—¥æœŸ', 'é€è¾¾åœ°å€', 'ä½å€', 'é€šè®¯åœ°å€',
                    'è”ç³»æ–¹å¼', 'è”ç³»ç”µè¯', 'è”ç³»é‚®ç®±', 'æˆæƒä»£è¡¨', 'æ³•å®šä»£è¡¨äºº',
                    'è¯ä»¶å·ç ', 'èº«ä»½è¯å·', 'ç»Ÿä¸€ç¤¾ä¼šä¿¡ç”¨ä»£ç ', 'æ³¨å†Œåœ°å€', 'åŠå…¬åœ°å€',
                    'é‚®æ”¿ç¼–ç ', 'å¼€æˆ·è¡Œ', 'è´¦å·'
                ]);

                // é€šç”¨é¡¹ç›®åç§°æ’é™¤åˆ—è¡¨
                const EXCLUDED_PROJECTS = new Set([
                    'è‚¡æƒæ¿€åŠ±è®¡åˆ’', 'å…¬å¸é«˜ç®¡è‚¡æƒæ¿€åŠ±è®¡åˆ’', 'å‘˜å·¥è‚¡æƒæ¿€åŠ±è®¡åˆ’', 'é™åˆ¶æ€§è‚¡ç¥¨æ¿€åŠ±è®¡åˆ’', 'è‚¡ç¥¨æœŸæƒæ¿€åŠ±è®¡åˆ’',
                    'è‚¡æƒæ¿€åŠ±', 'å‘˜å·¥æŒè‚¡è®¡åˆ’', 'é™åˆ¶æ€§è‚¡ç¥¨', 'è‚¡ç¥¨æœŸæƒ',
                    'å¢èµ„è®¡åˆ’', 'å¢èµ„é¡¹ç›®', 'èèµ„è®¡åˆ’', 'èèµ„é¡¹ç›®',
                    'æŠ•èµ„è®¡åˆ’', 'æŠ•èµ„é¡¹ç›®', 'åˆä½œè®¡åˆ’', 'åˆä½œé¡¹ç›®',
                    'å…¨å›½é¡¹ç›®', 'å›½å®¶é¡¹ç›®', 'çœçº§é¡¹ç›®', 'å¸‚çº§é¡¹ç›®',
                    'ä¸“é¡¹èµ„é‡‘', 'è´¢æ”¿èµ„é‡‘', 'é¢„ç®—èµ„é‡‘', 'è‡ªæœ‰èµ„é‡‘',
                    'ç ”å‘é¡¹ç›®', 'å»ºè®¾é¡¹ç›®', 'å®æ–½é¡¹ç›®',
                    'å·¥ç¨‹é¡¹ç›®', 'ç³»ç»Ÿé¡¹ç›®', 'å¹³å°é¡¹ç›®'
                ]);

                this.redactions = [];
                this.typeCounters = {};
                const fullText = this.document.paragraphs.join('\n');

                // æ˜¾ç¤ºå‰500å­—ç¬¦çš„åŸæ–‡ï¼ˆå¯è§†åŒ–æ¢è¡Œç¬¦ï¼‰
                if (this.debugMode) {
                    const preview = fullText.substring(0, 500).replace(/\n/g, 'â\n');
                    this.debugLog(`åŸæ–‡é¢„è§ˆ(å‰500å­—ç¬¦ï¼Œæ¢è¡Œç¬¦æ˜¾ç¤ºä¸ºâ):\n${preview}`);
                    this.debugLog('');
                }

                for (const rule of DEFAULT_RULES.rules) {
                    if (this.debugMode) {
                        this.debugLog(`=== å¤„ç†è§„åˆ™: ${rule.category} ===`);
                    }
                    // è°ƒè¯•ï¼šé’ˆå¯¹ç»Ÿä¸€ç¤¾ä¼šä¿¡ç”¨ä»£ç è§„åˆ™
                    if (rule.category === 'credit_code') {
                        console.log('=== è°ƒè¯•ç»Ÿä¸€ç¤¾ä¼šä¿¡ç”¨ä»£ç  ===');
                        console.log('è§„åˆ™:', rule);
                        console.log('å…¨æ–‡é¢„è§ˆ(å‰500å­—ç¬¦):', fullText.substring(0, 500));
                        console.log('å…¨æ–‡é•¿åº¦:', fullText.length);
                        // æŸ¥æ‰¾"ç»Ÿä¸€ç¤¾ä¼šä¿¡ç”¨ä»£ç "å‡ºç°ä½ç½®
                        const codeIndex = fullText.indexOf('ç»Ÿä¸€ç¤¾ä¼šä¿¡ç”¨ä»£ç ');
                        if (codeIndex !== -1) {
                            console.log('æ‰¾åˆ°"ç»Ÿä¸€ç¤¾ä¼šä¿¡ç”¨ä»£ç "åœ¨ä½ç½®:', codeIndex);
                            console.log('å‘¨å›´å­—ç¬¦(30å­—ç¬¦):', fullText.substring(codeIndex, codeIndex + 30));
                        }
                    }

                    for (const pattern of rule.patterns) {
                        const regex = new RegExp(pattern, 'g');

                        if (this.debugMode) {
                            this.debugLog(`  æ¨¡å¼: ${pattern}`);
                        }

                        if (rule.category === 'credit_code') {
                            console.log('---');
                            console.log('æ¨¡å¼:', pattern);
                            console.log('æ­£åˆ™å¯¹è±¡:', regex);
                            // æµ‹è¯•åŒ¹é…
                            const testMatch = regex.exec(fullText);
                            console.log('æµ‹è¯•åŒ¹é…ç»“æœ:', testMatch);
                            // é‡ç½®æ­£åˆ™çš„lastIndexï¼Œå› ä¸ºexecä¼šæ”¹å˜å®ƒ
                            regex.lastIndex = 0;
                        }

                        let match;
                        while ((match = regex.exec(fullText)) !== null) {
                            if (this.debugMode) {
                                this.debugLog(`  âœ“ åŒ¹é…: "${match[0]}" åœ¨ä½ç½® ${match.index}`);
                                if (match[1]) {
                                    this.debugLog(`    æ•è·ç»„: "${match[1]}"`);
                                }
                                // æ˜¾ç¤ºå‰å10ä¸ªå­—ç¬¦çš„ä¸Šä¸‹æ–‡
                                const contextStart = Math.max(0, match.index - 10);
                                const contextEnd = Math.min(fullText.length, match.index + match[0].length + 10);
                                const context = fullText.substring(contextStart, contextEnd).replace(/\n/g, 'â');
                                this.debugLog(`    ä¸Šä¸‹æ–‡: "...${context}..."`);
                            }

                            if (rule.category === 'credit_code') {
                                console.log('åŒ¹é…æˆåŠŸ:', match);
                            }
                            // è°ƒè¯•ï¼šé‡‘é¢è¯†åˆ«
                            if (rule.category === 'price') {
                                console.log('=== é‡‘é¢åŒ¹é…è°ƒè¯• ===');
                                console.log('æ¨¡å¼:', pattern);
                                console.log('å®Œæ•´åŒ¹é…:', match[0]);
                                console.log('æ‰€æœ‰æ•è·ç»„:', match.slice(1));
                                console.log('match[1]:', match[1]);
                                console.log('match[2]:', match[2]);
                                console.log('useCaptureGroup:', rule.useCaptureGroup);
                            }
                            // å¦‚æœä½¿ç”¨æ•è·ç»„ï¼Œä¼˜å…ˆä½¿ç”¨æ•è·ç»„å†…å®¹
                            const original = (rule.useCaptureGroup && match[1]) ? match[1] : match[0];
                            if (rule.category === 'price') {
                                console.log('æœ€ç»ˆoriginal:', original);
                            }
                            const startIndex = match.index;
                            const endIndex = startIndex + original.length;

                            // è¾¹ç•Œæ£€æŸ¥ï¼šé˜²æ­¢éƒ¨åˆ†åŒ¹é…ï¼ˆä½¿ç”¨å®Œæ•´åŒ¹é…é•¿åº¦è¿›è¡Œè¾¹ç•Œæ£€æŸ¥ï¼‰
                            if (rule.category === 'price') {
                                // ä½¿ç”¨ match[0].length è®¡ç®—ç”¨äºè¾¹ç•Œæ£€æŸ¥çš„ç»“æŸä½ç½®
                                const matchEndIndex = startIndex + match[0].length;

                                // æ£€æŸ¥åŒ¹é…å‰æ˜¯å¦æœ‰æ•°å­—å­—ç¬¦ï¼ˆè¡¨ç¤ºéƒ¨åˆ†åŒ¹é…ï¼‰
                                if (startIndex > 0 && /\d/.test(fullText[startIndex - 1])) {
                                    if (this.debugMode) {
                                        this.debugLog(`    âœ— è·³è¿‡: å‰é¢æœ‰æ•°å­—å­—ç¬¦`);
                                    }
                                    continue; // è·³è¿‡éƒ¨åˆ†åŒ¹é…
                                }
                                // æ£€æŸ¥åŒ¹é…åæ˜¯å¦ç´§è·Ÿæ•°å­—å­—ç¬¦æˆ–è¿å­—ç¬¦
                                if (matchEndIndex < fullText.length) {
                                    const nextChar = fullText[matchEndIndex];
                                    if (/\d/.test(nextChar)) {
                                        if (this.debugMode) {
                                            this.debugLog(`    âœ— è·³è¿‡: åé¢æœ‰æ•°å­—å­—ç¬¦"${nextChar}"`);
                                        }
                                        continue;
                                    }
                                    if (nextChar === '-') {
                                        if (this.debugMode) {
                                            this.debugLog(`    âœ— è·³è¿‡: åé¢ç´§è·Ÿè¿å­—ç¬¦"-"`);
                                        }
                                        continue;
                                    }
                                }
                            }

                            // æ£€æŸ¥æ˜¯å¦åŒ…å«æ¢è¡Œç¬¦ï¼ˆé’ˆå¯¹äººåå’Œåœ°å€è¯†åˆ«ï¼Œé˜²æ­¢è·¨è¡ŒåŒ¹é…ï¼‰
                            if ((rule.category === 'person_name' || rule.category === 'address') && match[0].includes('\n')) {
                                if (this.debugMode) {
                                    this.debugLog(`    âœ— è·³è¿‡: è·¨è¡ŒåŒ¹é… "${match[0].replace(/\n/g, 'â')}"`);
                                }
                                continue;
                            }

                            // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯è„±æ•æ ¼å¼ï¼ˆé˜²æ­¢åµŒå¥—è„±æ•ï¼‰
                            if (/^ã€[^ã€‘]+ã€‘$/.test(original)) {
                                if (this.debugMode) {
                                    this.debugLog(`    âœ— è·³è¿‡: "${original}" å·²æ˜¯è„±æ•æ ¼å¼`);
                                }
                                continue;
                            }

                            // æ£€æŸ¥æ˜¯å¦ä¸ºé€šç”¨è¯ï¼ˆä»…é’ˆå¯¹äººåè¯†åˆ«ï¼‰
                            if (rule.category === 'person_name' && EXCLUDED_TERMS.has(original)) {
                                if (this.debugMode) {
                                    this.debugLog(`    âœ— è·³è¿‡: "${original}" åœ¨æ’é™¤åˆ—è¡¨ä¸­`);
                                }
                                continue;
                            }

                            // æ£€æŸ¥æ˜¯å¦ä¸ºé€šç”¨é¡¹ç›®åç§°ï¼ˆä»…é’ˆå¯¹é¡¹ç›®åè¯†åˆ«ï¼‰
                            if (rule.category === 'project_name' && EXCLUDED_PROJECTS.has(original)) {
                                if (this.debugMode) {
                                    this.debugLog(`    âœ— è·³è¿‡: "${original}" åœ¨é¡¹ç›®æ’é™¤åˆ—è¡¨ä¸­`);
                                }
                                continue;
                            }

                            // æ£€æŸ¥åœ°å€å†…å®¹æ˜¯å¦åŒ…å«"è”ç³»ç”µè¯"ï¼ˆä»…é’ˆå¯¹åœ°å€è¯†åˆ«ï¼‰
                            if (rule.category === 'address' && original.includes('è”ç³»ç”µè¯')) {
                                if (this.debugMode) {
                                    this.debugLog(`    âœ— è·³è¿‡: "${original}" åŒ…å«"è”ç³»ç”µè¯"`);
                                }
                                continue;
                            }
                            // æ£€æŸ¥åœ°å€å†…å®¹æ˜¯å¦å¤ªçŸ­ï¼ˆå°‘äº3ä¸ªå­—ç¬¦ï¼‰
                            if (rule.category === 'address' && original.length < 3) {
                                if (this.debugMode) {
                                    this.debugLog(`    âœ— è·³è¿‡: "${original}" å¤ªçŸ­(${original.length}å­—ç¬¦)`);
                                }
                                continue;
                            }

                            // æ£€æŸ¥æ˜¯å¦è¢«ç™½åå•è¦†ç›–ï¼ˆç™½åå•ä¼˜å…ˆçº§é«˜äºè„±æ•ç±»åˆ«ï¼‰
                            if (isCoveredByWhitelist(original)) {
                                if (this.debugMode) {
                                    this.debugLog(`    âœ— è·³è¿‡: "${original}" è¢«ç™½åå•è¦†ç›–`);
                                }
                                continue;
                            }

                            if (this.isDuplicate(original)) {
                                if (this.debugMode) {
                                    this.debugLog(`    âœ— è·³è¿‡: "${original}" é‡å¤`);
                                }
                                continue;
                            }

                            if (this.debugMode) {
                                this.debugLog(`    â†’ å·²æ·»åŠ : "${original}" â†’ "${rule.replacement}"`);
                            }
                            this.typeCounters[rule.category] = (this.typeCounters[rule.category] || 0) + 1;
                            const replacement = rule.replacement.replace('${index}', this.typeCounters[rule.category]);

                            // è®¡ç®—ç”¨äºé«˜äº®çš„æ–‡æœ¬ï¼ˆåªé«˜äº®æ•è·ç»„éƒ¨åˆ†ï¼Œä¸åŒ…æ‹¬å‰ç¼€å’Œå°¾éšæ ‡ç‚¹ï¼‰
                            let highlightText = match[0];  // é»˜è®¤ä½¿ç”¨å®Œæ•´åŒ¹é…
                            if (rule.useCaptureGroup && match[1]) {
                                // å¦‚æœæœ‰æ•è·ç»„ï¼Œæ‰¾åˆ°æ•è·ç»„åœ¨å®Œæ•´åŒ¹é…ä¸­çš„ä½ç½®
                                const fullMatch = match[0];
                                const captured = match[1];
                                const capturedIndex = fullMatch.indexOf(captured);
                                if (capturedIndex !== -1) {
                                    // åªé«˜äº®æ•è·ç»„éƒ¨åˆ†ï¼ˆä»æ•è·ç»„å¼€å§‹åˆ°å®Œæ•´åŒ¹é…ç»“æŸï¼‰
                                    highlightText = fullMatch.substring(capturedIndex);

                                    // æ£€æŸ¥å°¾éƒ¨æ˜¯å¦æ˜¯çº¯æ ‡ç‚¹ç¬¦å·ï¼Œå¦‚æœæ˜¯åˆ™ç§»é™¤ï¼ˆç”¨äºæ¡ˆå·ç­‰ï¼‰
                                    const punctuationPattern = /[ï¼Œã€‚ã€,;ï¼.ï¼Ÿ]+$/;
                                    if (punctuationPattern.test(highlightText)) {
                                        highlightText = highlightText.replace(punctuationPattern, '');
                                    }
                                }
                            }

                            this.redactions.push({
                                id: Date.now() + Math.random(),
                                original: original,
                                matchText: match[0],  // å­˜å‚¨å®Œæ•´åŒ¹é…
                                highlightText: highlightText,  // ç”¨äºåŸæ–‡é¢„è§ˆé«˜äº®ï¼ˆåªé«˜äº®æ•è·ç»„éƒ¨åˆ†ï¼‰
                                replacement: replacement,
                                type: rule.category
                            });

                            // ç‰¹æ®Šå¤„ç†ï¼šç”µè¯å·ç è¯†åˆ«åï¼Œç»§ç»­åœ¨åŒä¸€è¡Œä¸­æŸ¥æ‰¾å…¶ä»–ç”µè¯
                            if (rule.category === 'phone') {
                                // æ£€æŸ¥å®Œæ•´çš„åŒ¹é…æ˜¯å¦åŒ…å«å‰ç¼€ï¼ˆè¯´æ˜è¿™æ˜¯ä»å¸¦å‰ç¼€çš„æ¨¡å¼åŒ¹é…çš„ï¼‰
                                const fullMatch = match[0];
                                if (fullMatch.includes('è”ç³»ç”µè¯') || fullMatch.includes('ç”µè¯ï¼š') || fullMatch.includes('æ‰‹æœºï¼š')) {
                                    // æ‰¾åˆ°å½“å‰è¡Œçš„ç»“æŸä½ç½®ï¼ˆæ¢è¡Œç¬¦æˆ–æ–‡æ¡£ç»“å°¾ï¼‰
                                    let lineEnd = fullText.indexOf('\n', endIndex);
                                    if (lineEnd === -1) lineEnd = fullText.length;

                                    // ä»å½“å‰åŒ¹é…ç»“æŸä½ç½®å¼€å§‹ï¼ŒæŸ¥æ‰¾åŒä¸€è¡Œä¸­çš„å…¶ä»–ç”µè¯å·ç 
                                    const remainingLine = fullText.substring(endIndex, lineEnd);

                                    // æ‰‹æœºå·æ¨¡å¼
                                    const mobilePattern = /1[3-9]\d{9}/g;
                                    // åº§æœºæ¨¡å¼ï¼ˆå¸¦åŒºå·ï¼‰
                                    const landlinePattern = /0\d{2,3}-?\d{7,8}/g;
                                    // åº§æœºæ¨¡å¼ï¼ˆæ‹¬å·åŒºå·ï¼‰
                                    const landlinePattern2 = /\(0\d{2,3}\)\d{7,8}/g;

                                    // æŸ¥æ‰¾æ‰€æœ‰æ‰‹æœºå·
                                    let mobileMatch;
                                    while ((mobileMatch = mobilePattern.exec(remainingLine)) !== null) {
                                        const phone = mobileMatch[0];
                                        if (!this.isDuplicate(phone) && phone !== original) {
                                            this.typeCounters[rule.category] = (this.typeCounters[rule.category] || 0) + 1;
                                            const extraReplacement = rule.replacement.replace('${index}', this.typeCounters[rule.category]);
                                            this.redactions.push({ id: Date.now() + Math.random(), original: phone, replacement: extraReplacement, type: rule.category });
                                        }
                                    }

                                    // æŸ¥æ‰¾æ‰€æœ‰åº§æœºå·ï¼ˆå¸¦åŒºå·ï¼‰
                                    let landlineMatch;
                                    while ((landlineMatch = landlinePattern.exec(remainingLine)) !== null) {
                                        const phone = landlineMatch[0];
                                        if (!this.isDuplicate(phone) && phone !== original) {
                                            this.typeCounters[rule.category] = (this.typeCounters[rule.category] || 0) + 1;
                                            const extraReplacement = rule.replacement.replace('${index}', this.typeCounters[rule.category]);
                                            this.redactions.push({ id: Date.now() + Math.random(), original: phone, replacement: extraReplacement, type: rule.category });
                                        }
                                    }

                                    // æŸ¥æ‰¾æ‰€æœ‰åº§æœºå·ï¼ˆæ‹¬å·åŒºå·ï¼‰
                                    let landlineMatch2;
                                    while ((landlineMatch2 = landlinePattern2.exec(remainingLine)) !== null) {
                                        const phone = landlineMatch2[0];
                                        if (!this.isDuplicate(phone) && phone !== original) {
                                            this.typeCounters[rule.category] = (this.typeCounters[rule.category] || 0) + 1;
                                            const extraReplacement = rule.replacement.replace('${index}', this.typeCounters[rule.category]);
                                            this.redactions.push({ id: Date.now() + Math.random(), original: phone, replacement: extraReplacement, type: rule.category });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // å¤„ç†é»‘åå•ï¼šå¼ºåˆ¶è„±æ•é»‘åå•ä¸­çš„å†…å®¹
                if (LISTS.blacklist.size > 0) {
                    if (this.debugMode) {
                        this.debugLog('=== å¤„ç†é»‘åå• ===');
                    }
                    const blacklistedItems = [...LISTS.blacklist];
                    for (const item of blacklistedItems) {
                        // å…¼å®¹æ—§æ ¼å¼ï¼ˆå­—ç¬¦ä¸²ï¼‰å’Œæ–°æ ¼å¼ï¼ˆå¯¹è±¡ï¼‰
                        const original = typeof item === 'string' ? item : item.original;
                        const itemType = typeof item === 'string' ? 'blacklist' : (item.type || 'blacklist');
                        const typeName = TYPE_NAMES[itemType] || TYPE_NAMES.blacklist;

                        // æ£€æŸ¥é»‘åå•é¡¹æ˜¯å¦åœ¨å…¨æ–‡ä¸­
                        if (fullText.includes(original)) {
                            // æ£€æŸ¥æ˜¯å¦å·²ç»è¢«è¯†åˆ«
                            if (!this.isDuplicate(original)) {
                                if (this.debugMode) {
                                    this.debugLog(`  âœ“ å¼ºåˆ¶è„±æ•ï¼ˆé»‘åå•-${typeName}ï¼‰: "${original}"`);
                                }
                                // ä½¿ç”¨è®°å½•çš„ç±»å‹ç”Ÿæˆæ›¿æ¢æ–‡æœ¬
                                this.typeCounters[itemType] = (this.typeCounters[itemType] || 0) + 1;
                                const replacement = `ã€${typeName}${this.typeCounters[itemType]}ã€‘`;

                                this.redactions.push({
                                    id: Date.now() + Math.random(),
                                    original: original,
                                    replacement: replacement,
                                    type: itemType
                                });
                            } else if (this.debugMode) {
                                this.debugLog(`  - å·²åœ¨è¯†åˆ«åˆ—è¡¨ä¸­: "${original}"`);
                            }
                        }
                    }
                }

                // å¤„ç†è‡ªå®šä¹‰è„±æ•ç±»å‹
                if (LISTS.customTypes.size > 0) {
                    if (this.debugMode) {
                        this.debugLog('=== å¤„ç†è‡ªå®šä¹‰è„±æ•ç±»å‹ ===');
                    }
                    for (const [typeName, items] of LISTS.customTypes) {
                        if (this.debugMode) {
                            this.debugLog(`å¤„ç†ç±»å‹: ${typeName} (${items.size} é¡¹)`);
                        }
                        for (const item of items) {
                            const original = item.original;

                            // æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•ä¸­ï¼ˆé»‘åå•ä¼˜å…ˆçº§æœ€é«˜ï¼‰
                            const inBlacklist = [...LISTS.blacklist].some(b => b.original === original);
                            if (inBlacklist) {
                                if (this.debugMode) {
                                    this.debugLog(`  - è·³è¿‡: "${original}" åœ¨é»‘åå•ä¸­ï¼ˆé»‘åå•ä¼˜å…ˆï¼‰`);
                                }
                                continue;
                            }

                            // æ£€æŸ¥æ˜¯å¦è¢«ç™½åå•è¦†ç›–ï¼ˆç™½åå•ä¼˜å…ˆçº§é«˜äºè‡ªå®šä¹‰ç±»å‹ï¼‰
                            if (isCoveredByWhitelist(original)) {
                                if (this.debugMode) {
                                    this.debugLog(`  - è·³è¿‡: "${original}" è¢«ç™½åå•è¦†ç›–`);
                                }
                                continue;
                            }

                            // æ£€æŸ¥æ˜¯å¦åœ¨å…¨æ–‡ä¸­
                            const index = fullText.indexOf(original);
                            if (index !== -1) {
                                // æ£€æŸ¥æ˜¯å¦å·²ç»è¢«è¯†åˆ«
                                if (!this.isDuplicate(original)) {
                                    if (this.debugMode) {
                                        this.debugLog(`  âœ“ åŒ¹é…: "${original}" -> ã€${typeName}ã€‘`);
                                    }
                                    this.typeCounters['custom-' + typeName] = (this.typeCounters['custom-' + typeName] || 0) + 1;
                                    const replacement = `ã€${typeName}${this.typeCounters['custom-' + typeName]}ã€‘`;

                                    this.redactions.push({
                                        id: Date.now() + Math.random(),
                                        original: original,
                                        replacement: replacement,
                                        type: 'custom-' + typeName,
                                        location: 'è‡ªå®šä¹‰ç±»å‹'
                                    });
                                } else if (this.debugMode) {
                                    this.debugLog(`  - å·²åœ¨è¯†åˆ«åˆ—è¡¨ä¸­: "${original}"`);
                                }
                            }
                        }
                    }
                }

                this.updateStats();
                this.render(); // ç¡®ä¿ç»Ÿè®¡æ•°æ®æ›´æ–°
            }

            isDuplicate(original) { return this.redactions.some(r => r.original === original); }

            // æ£€æŸ¥å†…å®¹æ˜¯å¦åœ¨å…¶ä»–åˆ—è¡¨ä¸­å­˜åœ¨ï¼ˆé˜²æ­¢å†²çªï¼‰
            checkConflict(content, targetListType, targetTypeName = null) {
                // targetListType: 'whitelist' | 'blacklist' | 'custom'
                // targetTypeName: è‡ªå®šä¹‰ç±»å‹åç§°ï¼ˆå½“ targetListType === 'custom' æ—¶ï¼‰
                const conflicts = [];

                // æ£€æŸ¥ç™½åå•
                if (targetListType !== 'whitelist' && LISTS.whitelist.has(content)) {
                    conflicts.push({ list: 'ç™½åå•', content });
                }

                // æ£€æŸ¥é»‘åå•
                if (targetListType !== 'blacklist' && LISTS.blacklist.has(content)) {
                    conflicts.push({ list: 'é»‘åå•', content });
                }

                // æ£€æŸ¥è‡ªå®šä¹‰ç±»å‹
                for (const [typeName, items] of LISTS.customTypes) {
                    const existingItem = [...items].find(item => item.original === content);
                    if (existingItem) {
                        if (targetListType === 'custom' && typeName === targetTypeName) {
                            // åŒä¸€ç±»å‹å†…é‡å¤
                            conflicts.push({ list: `è‡ªå®šä¹‰ç±»å‹ã€Œ${typeName}ã€`, content, sameType: true });
                        } else if (targetListType !== 'custom' || typeName !== targetTypeName) {
                            // è·¨ç±»å‹å†²çª
                            conflicts.push({ list: `è‡ªå®šä¹‰ç±»å‹ã€Œ${typeName}ã€`, content });
                        }
                    }
                }

                return conflicts;
            }

            render() {
                const container = document.getElementById('originalPreview');

                // === è°ƒè¯•1ï¼šredactionsåŸºæœ¬ä¿¡æ¯ ===
                console.log('=== Renderè°ƒè¯•å¼€å§‹ ===');
                console.log('Redactionsæ€»æ•°:', this.redactions.length);

                // æŒ‰åŸæ–‡é•¿åº¦é™åºæ’åºï¼ˆé•¿æ–‡æœ¬ä¼˜å…ˆï¼Œé¿å…çŸ­æ–‡æœ¬ç ´åé•¿æ–‡æœ¬ï¼‰
                const sortedRedactions = [...this.redactions].sort((a, b) => b.original.length - a.original.length);

                // === è°ƒè¯•2ï¼šæ’åºåçš„redactions ===
                console.log('æ’åºåredactionsï¼ˆå‰10ä¸ªï¼‰:');
                sortedRedactions.slice(0, 10).forEach((r, i) => {
                    console.log(`  [${i}] id=${r.id}, original="${r.original}" (${r.original.length}å­—ç¬¦)`);
                });

                // === è°ƒè¯•3ï¼šæ£€æŸ¥å¯èƒ½é‡å¤çš„originalå€¼ ===
                const originalMap = {};
                this.redactions.forEach(r => {
                    if (!originalMap[r.original]) {
                        originalMap[r.original] = [];
                    }
                    originalMap[r.original].push(r.id);
                });
                const duplicates = Object.entries(originalMap).filter(([text, ids]) => ids.length > 1);
                if (duplicates.length > 0) {
                    console.warn('å‘ç°é‡å¤çš„originalå€¼:');
                    duplicates.forEach(([text, ids]) => {
                        console.warn(`  "${text}": ${ids.length}ä¸ªredaction, IDs=[${ids.join(', ')}]`);
                    });
                }

                // === è°ƒè¯•4ï¼šé€æ®µè½è·Ÿè¸ªæ›¿æ¢ ===
                let totalReplacements = 0;
                const paragraphCounts = [];
                // ä½¿ç”¨è®¡æ•°å™¨ä¸ºæ¯ä¸ªspanç”Ÿæˆå”¯ä¸€ID
                let spanCounter = 0;

                container.innerHTML = this.document.paragraphs.map((p, pIdx) => {
                    let text = this.escapeHtml(p);
                    let paraReplacements = 0;

                    sortedRedactions.forEach(r => {
                        // ä½¿ç”¨ highlightText è¿›è¡ŒåŸæ–‡é¢„è§ˆé«˜äº®ï¼ˆåªé«˜äº®æ•è·ç»„éƒ¨åˆ†ï¼‰
                        const highlightText = r.highlightText || r.matchText || r.original;
                        // ä½¿ç”¨'g'æ ‡å¿—æ›¿æ¢æ‰€æœ‰åŒ¹é…ï¼Œå¹¶ä¸ºæ¯ä¸ªåŒ¹é…ç”Ÿæˆå”¯ä¸€span ID
                        const regex = new RegExp(this.escapeRegex(highlightText), 'g');
                        text = text.replace(regex, (match) => {
                            const uniqueSpanId = `${r.id}-${spanCounter++}`;
                            paraReplacements++;
                            totalReplacements++;
                            return `<span class="redacted" id="redaction-span-${uniqueSpanId}" onclick="app.scrollToRedaction(${r.id})">${match}</span>`;
                        });
                    });

                    if (paraReplacements > 0) {
                        paragraphCounts.push({ pIdx: pIdx + 1, count: paraReplacements });
                    }
                    return `<p class="preview-text">${text}</p>`;
                }).join('');

                // === è°ƒè¯•5ï¼šæ›¿æ¢ç»Ÿè®¡ ===
                console.log('æ›¿æ¢ç»Ÿè®¡:');
                console.log(`  æ€»æ›¿æ¢æ¬¡æ•°: ${totalReplacements}`);
                console.log(`  æœ‰æ›¿æ¢çš„æ®µè½: ${paragraphCounts.length}ä¸ª`);
                console.log(`  æ®µè½è¯¦æƒ…:`, paragraphCounts.map(x => `æ®µè½${x.pIdx}: ${x.count}æ¬¡`).join(', '));

                const list = document.getElementById('redactionList');
                if (this.redactions.length === 0) { list.innerHTML = '<p style="color:#999;text-align:center;">æš‚æ— è„±æ•é¡¹</p>'; return; }
                list.innerHTML = this.redactions.map(r => {
                    // å¤„ç†è‡ªå®šä¹‰ç±»å‹çš„ç±»å‹åç§°æ˜¾ç¤º
                    const typeName = r.type.startsWith('custom-') ? r.type.replace('custom-', '') : (TYPE_NAMES[r.type] || r.type);
                    return `
                    <div class="redaction-item" id="redaction-item-${r.id}" onclick="app.scrollToOriginal(${r.id})">
                        <span class="type-${r.type}" style="display:inline-block;padding:3px 8px;border-radius:4px;font-size:11px;">${this.escapeHtml(typeName)}</span>
                        <div class="redaction-original">åŸæ–‡: ${r.original}</div>
                        <div class="redaction-replacement">æ›¿æ¢: ${r.replacement}</div>
                        <div class="redaction-location" onclick="event.stopPropagation();app.editRedaction(${r.id})" style="cursor:pointer;">ç‚¹å‡»ä¿®æ”¹</div>
                        <div class="redaction-actions"><button class="btn-xs btn-danger" onclick="event.stopPropagation();app.deleteRedaction(${r.id})">åˆ é™¤</button></div>
                    </div>
                    `;
                }).join('');
                document.getElementById('redactionCount').textContent = this.redactions.length + ' é¡¹';

                const preview = document.getElementById('redactedPreview');
                preview.innerHTML = this.document.paragraphs.map(p => {
                    let text = this.escapeHtml(p);
                    // ä½¿ç”¨ matchText è¿›è¡Œç²¾ç¡®æ›¿æ¢ï¼Œé¿å…è¯¯æ›¿æ¢
                    sortedRedactions.forEach(r => {
                        const replaceTarget = r.matchText || r.original;
                        text = text.replace(new RegExp(this.escapeRegex(replaceTarget), 'g'),
                            `<span class="redacted-preview">${r.replacement}</span>`);
                    });
                    return `<p class="preview-text">${text}</p>`;
                }).join('');

                // åŒæ­¥æ»šåŠ¨
                this.setupScrollSync(container, preview);

                // === è°ƒè¯•6ï¼šæœ€ç»ˆspanæ£€æŸ¥ï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿DOMå·²æ›´æ–°ï¼‰ ===
                setTimeout(() => {
                    const allSpans = container.querySelectorAll('span.redacted');
                    console.log('=== æœ€ç»ˆHTMLåˆ†æ ===');
                    console.log(`ç”Ÿæˆäº† ${allSpans.length} ä¸ªspanï¼ˆredactions=${this.redactions.length}ï¼Œå¤šå‡º${allSpans.length - this.redactions.length}ä¸ªæ˜¯é‡å¤æ–‡æœ¬ï¼‰`);

                    // æ”¶é›†æ‰€æœ‰spançš„ID
                    const spanIds = [];
                    allSpans.forEach((span, i) => {
                        spanIds.push(span.id);
                    });

                    // æ£€æŸ¥é‡å¤ID
                    const idCounts = {};
                    spanIds.forEach(id => {
                        idCounts[id] = (idCounts[id] || 0) + 1;
                    });
                    const duplicateIds = Object.entries(idCounts).filter(([id, count]) => count > 1);
                    if (duplicateIds.length > 0) {
                        console.error('âŒ å‘ç°é‡å¤ID:');
                        duplicateIds.forEach(([id, count]) => {
                            const spans = Array.from(allSpans).filter(s => s.id === id);
                            console.error(`  ID=${id}: å‡ºç°${count}æ¬¡, æ–‡æœ¬=[${spans.map(s => s.textContent).join(', ')}]`);
                        });
                    } else {
                        console.log('âœ“ æ²¡æœ‰é‡å¤ID - æ‰€æœ‰span IDå”¯ä¸€');
                    }
                }, 100);

            }

            setupScrollSync(el1, el2) {
                let syncing = false;
                el1.onscroll = () => {
                    if (syncing) return;
                    syncing = true;
                    const ratio = el1.scrollTop / (el1.scrollHeight - el1.clientHeight);
                    el2.scrollTop = ratio * (el2.scrollHeight - el2.clientHeight);
                    setTimeout(() => syncing = false, 10);
                };
                el2.onscroll = () => {
                    if (syncing) return;
                    syncing = true;
                    const ratio = el2.scrollTop / (el2.scrollHeight - el2.clientHeight);
                    el1.scrollTop = ratio * (el1.scrollHeight - el1.clientHeight);
                    setTimeout(() => syncing = false, 10);
                };
            }

            scrollToRedaction(id) {
                const item = document.getElementById(`redaction-item-${id}`);
                if (item) {
                    item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    item.style.background = '#fff3cd';
                    setTimeout(() => item.style.background = '#f8f9fa', 1000);
                }
            }

            scrollToOriginal(id) {
                // æ‰¾åˆ°è¯¥redactionå¯¹åº”çš„æ‰€æœ‰spanï¼ˆIDæ ¼å¼ï¼šredaction-span-${id}-${counter}ï¼‰
                const allSpans = document.querySelectorAll(`span[id^="redaction-span-${id}"]`);
                const item = document.getElementById(`redaction-item-${id}`);

                if (allSpans.length > 0) {
                    // å®šä½åˆ°ç¬¬ä¸€ä¸ªspan
                    const span = allSpans[0];
                    span.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    span.classList.add('orange-flash');
                    setTimeout(() => span.classList.remove('orange-flash'), 1800);
                }

                if (item) {
                    // è„±æ•é¡¹åˆ—è¡¨é—ªçƒï¼ˆæ·¡é»„è‰²ï¼Œä¸åŸæ–‡é«˜äº®ä¸€è‡´ï¼‰
                    item.style.background = '#fff3cd';
                    setTimeout(() => item.style.background = '#f8f9fa', 800);

                    // æ™ºèƒ½æ»šåŠ¨ï¼šæ ¹æ®ç‚¹å‡»å†å²å†³å®šæ–¹å‘
                    const container = document.getElementById('redactionList');
                    const itemHeight = item.clientHeight;
                    const scrollDistance = itemHeight + 10;

                    // ç¡®å®šæ»šåŠ¨æ–¹å‘
                    if (this.lastClickedId !== null) {
                        const lastItem = document.getElementById(`redaction-item-${this.lastClickedId}`);
                        if (lastItem) {
                            // æ¯”è¾ƒä½ç½®ï¼šå½“å‰é¡¹åœ¨ä¸Šæ¬¡ç‚¹å‡»é¡¹çš„ä¸‹æ–¹ â†’ å‘ä¸‹æ»šåŠ¨ï¼Œå¦åˆ™å‘ä¸Šæ»šåŠ¨
                            if (item.offsetTop > lastItem.offsetTop) {
                                this.scrollDirection = 'down';  // ç‚¹å‡»ä¸‹é¢çš„é¡¹ï¼Œå‘ä¸‹æ»šåŠ¨
                            } else if (item.offsetTop < lastItem.offsetTop) {
                                this.scrollDirection = 'up';  // ç‚¹å‡»ä¸Šé¢çš„é¡¹ï¼Œå‘ä¸Šæ»šåŠ¨
                            }
                            // ä½ç½®ç›¸åŒåˆ™ä¿æŒå½“å‰æ–¹å‘
                        }
                    }

                    // æ‰§è¡Œæ»šåŠ¨
                    if (this.scrollDirection === 'up') {
                        container.scrollTo({ top: container.scrollTop - scrollDistance, behavior: 'smooth' });
                    } else {
                        container.scrollTo({ top: container.scrollTop + scrollDistance, behavior: 'smooth' });
                    }

                    // æ›´æ–°çŠ¶æ€
                    this.lastClickedId = id;
                }
            }

            escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }
            escapeRegex(text) { return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
            updateStats() { document.getElementById('totalCount').textContent = this.redactions.length; document.getElementById('paragraphCount').textContent = this.document.paragraphs.length; }

            deleteRedaction(id) {
                const r = this.redactions.find(x => x.id === id);
                if (!r) return;

                // æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•ä¸­ï¼ˆé»‘åå•å­˜å‚¨çš„æ˜¯å¯¹è±¡ {original, type}ï¼‰
                const inBlacklist = [...LISTS.blacklist].some(item => item.original === r.original);

                // æ£€æŸ¥æ˜¯å¦åœ¨è‡ªå®šä¹‰ç±»å‹ä¸­
                let inCustomType = null;
                for (const [typeName, items] of LISTS.customTypes) {
                    if ([...items].some(item => item.original === r.original)) {
                        inCustomType = typeName;
                        break;
                    }
                }

                // å¦‚æœåœ¨é»‘åå•æˆ–è‡ªå®šä¹‰ç±»å‹ä¸­ï¼Œæ˜¾ç¤ºè­¦å‘Š
                if (inBlacklist || inCustomType) {
                    const listName = inBlacklist ? 'é»‘åå•' : `è‡ªå®šä¹‰ç±»å‹ã€Œ${inCustomType}ã€`;
                    alert(`âš ï¸ æ— æ³•ç›´æ¥æ·»åŠ åˆ°ç™½åå•\n\n"${r.original}" å­˜åœ¨äº${listName}ä¸­ã€‚\n\nè¯·å…ˆä»${listName}ä¸­æ‰‹åŠ¨åˆ é™¤è¯¥å†…å®¹ï¼Œç„¶åå†æ·»åŠ åˆ°ç™½åå•ã€‚`);
                } else {
                    // ä¸åœ¨é»‘åå•/è‡ªå®šä¹‰ç±»å‹ä¸­ï¼Œè¯¢é—®æ˜¯å¦åŠ å…¥ç™½åå•
                    const confirmed = confirm(`"${r.original}" å·²ä»è„±æ•åˆ—è¡¨ç§»é™¤\n\næ˜¯å¦åŒæ—¶æ·»åŠ åˆ°ç™½åå•ï¼Ÿ\nä»¥åé‡åˆ°ç›¸åŒå†…å®¹å°†ä¸å†è„±æ•`);
                    if (confirmed) {
                        // ä½¿ç”¨è¿ç§»æ¨¡å¼ï¼šå…ˆä»åŸåˆ—è¡¨åˆ é™¤ï¼Œå†æ·»åŠ åˆ°ç™½åå•
                        addToWhitelist(r.original, true);
                    }
                }

                this.redactions = this.redactions.filter(x => x.id !== id);
                this.render();
                this.updateStats();
            }
            editRedaction(id) { const r = this.redactions.find(x => x.id === id); if (!r) return; const newRep = prompt('ä¿®æ”¹æ›¿æ¢æ–‡æœ¬:', r.replacement); if (newRep !== null) { r.replacement = newRep.trim(); this.render(); } }

            showAddModal(prefillText = '') {
                document.getElementById('addModal').classList.add('show');
                if (prefillText) {
                    document.getElementById('manualOriginal').value = prefillText;
                }
            }
            hideAddModal() { document.getElementById('addModal').classList.remove('show'); }

            // æ˜¾ç¤ºå†²çªå¼¹çª—
            showConflictModal(item, conflicts) {
                const modal = document.getElementById('conflictModal');
                const messageEl = document.getElementById('conflictMessage');

                // æ„å»ºå†²çªæ¶ˆæ¯
                let message = `ã€Œ${item}ã€å·²å­˜åœ¨äºä»¥ä¸‹åˆ—è¡¨ä¸­ï¼š\n\n`;
                conflicts.forEach(c => {
                    message += `â€¢ ${c.list}\n`;
                });
                messageEl.innerText = message;

                modal.classList.add('show');
            }

            // å…³é—­å†²çªå¼¹çª—
            closeConflictModal() {
                document.getElementById('conflictModal').classList.remove('show');
            }

            addManualRedaction() {
                const original = document.getElementById('manualOriginal').value.trim();
                const selected = document.querySelector('.type-option.selected');
                if (!original) { alert('è¯·è¾“å…¥åŸæ–‡'); return; }
                if (!selected) { alert('è¯·é€‰æ‹©ç±»å‹'); return; }

                // æ£€æŸ¥æ˜¯å¦åœ¨ç™½åå•ä¸­
                if (LISTS.whitelist.has(original)) {
                    alert(`âš ï¸ æ— æ³•æ·»åŠ è„±æ•é¡¹\n\n"${original}" å­˜åœ¨äºç™½åå•ä¸­ã€‚\n\nç™½åå•å†…å®¹ä¸ä¼šè¢«è„±æ•ï¼Œå¦‚éœ€è„±æ•è¯·å…ˆä»ç™½åå•ä¸­åˆ é™¤è¯¥å†…å®¹ã€‚`);
                    return;
                }

                const type = selected.dataset.type;
                this.typeCounters[type] = (this.typeCounters[type] || 0) + 1;
                // å¤„ç†è‡ªå®šä¹‰ç±»å‹çš„ç±»å‹åç§°
                const typeName = type.startsWith('custom-') ? type.replace('custom-', '') : TYPE_NAMES[type];
                const replacement = prompt('æ›¿æ¢æ–‡æœ¬ï¼ˆç•™ç©ºè‡ªåŠ¨ç”Ÿæˆï¼‰') || `ã€${typeName}${this.typeCounters[type]}ã€‘`;
                this.redactions.push({ id: Date.now(), original, replacement, type, location: 'æ‰‹åŠ¨æ·»åŠ ' });

                // æ ¹æ®ç±»å‹é€‰æ‹©ï¼Œæ‰§è¡Œä¸åŒæ“ä½œ
                if (type.startsWith('custom-')) {
                    // è‡ªå®šä¹‰ç±»å‹ï¼šæ·»åŠ åˆ°å¯¹åº”çš„è‡ªå®šä¹‰ç±»å‹ä¸­
                    const customTypeName = type.replace('custom-', '');
                    if (!LISTS.customTypes.has(customTypeName)) {
                        LISTS.customTypes.set(customTypeName, new Set());
                    }
                    const items = LISTS.customTypes.get(customTypeName) || new Set();
                    items.add({ original, id: Date.now() + Math.random() });
                    LISTS.customTypes.set(customTypeName, items);
                    saveCustomTypes();
                } else {
                    // é»˜è®¤ç±»å‹ï¼šè¯¢é—®æ˜¯å¦åŠ å…¥é»‘åå•
                    const confirmed = confirm(`"${original}" å·²æ·»åŠ åˆ°è„±æ•åˆ—è¡¨\n\næ˜¯å¦åŒæ—¶æ·»åŠ åˆ°é»‘åå•ï¼Ÿ\nä»¥åé‡åˆ°ç›¸åŒå†…å®¹å°†è‡ªåŠ¨è„±æ•`);
                    if (confirmed) {
                        addToBlacklist(original, type);  // ä¼ é€’ç±»å‹å‚æ•°
                    }
                }

                this.hideAddModal();
                this.render();
                this.updateStats();
            }

            showExportModal() { document.getElementById('exportModal').classList.add('show'); }
            hideExportModal() { document.getElementById('exportModal').classList.remove('show'); }

            handleTextSelection() {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();

                // åªæœ‰é€‰æ‹©äº†åŸæ–‡é¢„è§ˆä¸­çš„æ–‡æœ¬ï¼Œä¸”é•¿åº¦åœ¨2-100å­—ç¬¦ä¹‹é—´æ‰æ˜¾ç¤ºå¼¹çª—
                if (selectedText && selectedText.length >= 2 && selectedText.length <= 100) {
                    // æ£€æŸ¥é€‰æ‹©æ˜¯å¦åœ¨åŸæ–‡é¢„è§ˆå†…
                    const container = document.getElementById('originalPreview');
                    if (container.contains(selection.anchorNode)) {
                        this.showAddModalWithText(selectedText);
                    }
                }
            }

            showAddModalWithText(text) {
                this.showAddModal(text);
            }
            exportResults() {
                if (document.getElementById('exportDocx').checked) this.exportDocx();
                if (document.getElementById('exportMapping').checked) this.exportMappingMD();
                this.hideExportModal();
            }

            // ==================== ç™½åå•/é»‘åå•ç®¡ç†æ–¹æ³• ====================

            showListModal() {
                this.renderLists();
                document.getElementById('listModal').classList.add('show');
            }

            closeListModal() {
                document.getElementById('listModal').classList.remove('show');
            }

            saveAndCloseListModal() {
                saveLists();
                this.closeListModal();
                // å¦‚æœæœ‰æ–‡æ¡£åŠ è½½ï¼Œé‡æ–°è¯†åˆ«
                if (this.document) {
                    this.identifyRedactions();
                    this.render();
                }
            }

            renderLists() {
                // æ¸²æŸ“ç™½åå•
                const whitelistContainer = document.getElementById('whitelistContainer');
                if (LISTS.whitelist.size > 0) {
                    whitelistContainer.innerHTML = [...LISTS.whitelist].map(item => `
                        <div style="display:flex; justify-content:space-between; align-items:center; padding:5px; margin-bottom:5px; background:white; border-radius:4px; border:1px solid #e0e0e0;">
                            <span style="flex:1; word-break:break-all; padding:5px;">${this.escapeHtml(item)}</span>
                            <button class="btn-xs btn-danger" onclick="app.removeFromWhitelistUI('${this.escapeHtml(item).replace(/'/g, "\\'")}')"
                                    style="padding:2px 8px; margin-left:5px; flex-shrink:0;">Ã—</button>
                        </div>
                    `).join('');
                } else {
                    whitelistContainer.innerHTML = '<p style="color:#999; text-align:center; padding:20px 0;">æš‚æ— ç™½åå•é¡¹</p>';
                }

                // æ¸²æŸ“é»‘åå•
                const blacklistContainer = document.getElementById('blacklistContainer');
                if (LISTS.blacklist.size > 0) {
                    blacklistContainer.innerHTML = [...LISTS.blacklist].map(item => {
                        // å…¼å®¹æ—§æ ¼å¼ï¼ˆå­—ç¬¦ä¸²ï¼‰å’Œæ–°æ ¼å¼ï¼ˆå¯¹è±¡ï¼‰
                        const original = typeof item === 'string' ? item : item.original;
                        const type = typeof item === 'string' ? 'blacklist' : (item.type || 'blacklist');
                        const typeName = TYPE_NAMES[type] || TYPE_NAMES.blacklist;

                        return `
                        <div style="display:flex; justify-content:space-between; align-items:center; padding:5px; margin-bottom:5px; background:white; border-radius:4px; border:1px solid #e0e0e0;">
                            <div style="flex:1; display:flex; align-items:center; gap:8px;">
                                <span style="word-break:break-all;">${this.escapeHtml(original)}</span>
                                <span class="type-${type}" style="display:inline-block;padding:2px 6px;border-radius:3px;font-size:10px;background:#f0f0f0;flex-shrink:0;">
                                    ${typeName}
                                </span>
                            </div>
                            <button class="btn-xs btn-danger" onclick="app.removeFromBlacklistUI('${this.escapeHtml(original).replace(/'/g, "\\'")}')"
                                    style="padding:2px 8px; margin-left:5px; flex-shrink:0;">Ã—</button>
                        </div>
                        `;
                    }).join('');
                } else {
                    blacklistContainer.innerHTML = '<p style="color:#999; text-align:center; padding:20px 0;">æš‚æ— é»‘åå•é¡¹</p>';
                }
            }

            addToWhitelistFromUI() {
                const input = document.getElementById('whitelistInput');
                const value = input.value.trim();
                if (!value) return;

                // æ£€æŸ¥å†²çª
                const conflicts = this.checkConflict(value, 'whitelist');
                if (conflicts.length > 0) {
                    this.showConflictModal(value, conflicts);
                    return;
                }

                addToWhitelist(value);
                input.value = '';
                this.renderLists();
            }

            addToBlacklistFromUI() {
                const input = document.getElementById('blacklistInput');
                const value = input.value.trim();
                if (!value) return;

                // æ£€æŸ¥å†²çª
                const conflicts = this.checkConflict(value, 'blacklist');
                if (conflicts.length > 0) {
                    this.showConflictModal(value, conflicts);
                    return;
                }

                addToBlacklist(value);
                input.value = '';
                this.renderLists();
            }

            removeFromWhitelistUI(item) {
                removeFromWhitelist(item);
                this.renderLists();
            }

            removeFromBlacklistUI(item) {
                removeFromBlacklist(item);
                this.renderLists();
            }

            // ==================== è‡ªå®šä¹‰è„±æ•ç±»å‹ç®¡ç†æ–¹æ³• ====================

            showCustomTypeModal() {
                this.renderCustomTypesList();
                document.getElementById('customTypeModal').classList.add('show');
            }

            hideCustomTypeModal() {
                document.getElementById('customTypeModal').classList.remove('show');

                // å…ˆå…³é—­å…¶ä»–å¯èƒ½æ‰“å¼€çš„å¼¹çª—ï¼ˆå¦‚"æ‰‹åŠ¨æ·»åŠ è„±æ•é¡¹"ï¼‰ï¼Œé¿å…é®æŒ¡æ›´æ–°çš„é¢„è§ˆ
                this.hideAddModal();
                this.hideExportModal();
                this.hideListModal();

                // ç„¶åè§¦å‘é‡æ–°è¯†åˆ«ï¼Œç¡®ä¿é¢„è§ˆåŒæ­¥æ›´æ–°
                this.identifyRedactions();
            }

            renderCustomTypesList() {
                const container = document.getElementById('customTypesList');
                if (LISTS.customTypes.size === 0) {
                    container.innerHTML = '<p style="color:#999; text-align:center; padding:20px 0;">æš‚æ— è‡ªå®šä¹‰ç±»å‹<br>ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ </p>';
                    return;
                }

                container.innerHTML = [...LISTS.customTypes.keys()].map(typeName => {
                    const items = LISTS.customTypes.get(typeName);
                    const count = items ? items.size : 0;
                    return `
                        <div class="custom-type-item" onclick="app.selectTypeForEdit('${this.escapeHtml(typeName).replace(/'/g, "\\'")}')">
                            <div class="type-item-header">
                                <span class="type-name">${this.escapeHtml(typeName)}</span>
                                <button class="btn-xs btn-danger" onclick="event.stopPropagation(); app.deleteCustomType('${this.escapeHtml(typeName).replace(/'/g, "\\'")}')"
                                        style="padding:4px 8px;">Ã—</button>
                            </div>
                            <div class="item-count">ï¼ˆ${count}é¡¹ï¼‰</div>
                        </div>
                    `;
                }).join('');
            }

            promptAddType() {
                const typeName = prompt('è¯·è¾“å…¥æ–°çš„è„±æ•ç±»å‹åç§°ï¼š');
                if (!typeName || !typeName.trim()) return;

                const trimmedName = typeName.trim();
                if (LISTS.customTypes.has(trimmedName)) {
                    alert('ç±»å‹ "' + trimmedName + '" å·²å­˜åœ¨ï¼');
                    return;
                }

                LISTS.customTypes.set(trimmedName, new Set());
                saveCustomTypes();
                this.renderCustomTypesList();
                initTypeSelector();
            }

            selectTypeForEdit(typeName) {
                currentEditingType = typeName;
                const items = LISTS.customTypes.get(typeName) || new Set();

                document.getElementById('typeEditorArea').innerHTML = `
                    <h4 style="margin-bottom:10px;">ç¼–è¾‘: <span style="color:#28a745;">${this.escapeHtml(typeName)}</span></h4>
                    <div class="form-group">
                        <label>ç²¾å‡†åŒ¹é…å†…å®¹ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰</label>
                        <textarea id="editingTypeItems" rows="10"
                            placeholder="è¾“å…¥å†…å®¹ï¼Œæ¯è¡Œä¸€ä¸ª" style="width:100%; padding:10px; border:1px solid #ddd; border-radius:4px;"></textarea>
                    </div>
                    <div style="margin-top:15px;">
                        <button class="btn btn-success" onclick="app.saveTypeItems()">ğŸ’¾ ä¿å­˜å†…å®¹</button>
                    </div>
                    <div id="typeItemsList" style="margin-top:15px; max-height:200px; overflow-y:auto;">
                        ${[...items].map(item => `
                            <div class="type-item-row" data-item-id="${item.id}">
                                <span class="item-text">${this.escapeHtml(item.original)}</span>
                                <button class="btn-mini btn-danger" onclick="event.stopPropagation(); app.deleteTypeItem('${item.id}')">âœ•</button>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            saveTypeItems() {
                if (!currentEditingType) return;

                const textarea = document.getElementById('editingTypeItems');
                const content = textarea.value.trim();
                if (!content) return;

                // è·å–å·²å­˜åœ¨çš„é¡¹
                const existingItems = LISTS.customTypes.get(currentEditingType) || new Set();
                const newItems = new Set([...existingItems]);

                // è§£ææ–°è¾“å…¥çš„è¡Œ
                const lines = content.split('\n').map(l => l.trim()).filter(l => l);
                const now = Date.now();

                // æ£€æŸ¥æ¯ä¸ªæ–°é¡¹æ˜¯å¦æœ‰å†²çª
                const conflicts = [];
                for (const line of lines) {
                    const itemConflicts = this.checkConflict(line, 'custom', currentEditingType);
                    if (itemConflicts.length > 0) {
                        conflicts.push({ item: line, conflicts: itemConflicts });
                    }
                }

                if (conflicts.length > 0) {
                    // æ˜¾ç¤ºå†²çªä¿¡æ¯
                    let message = 'ä»¥ä¸‹å†…å®¹å·²å­˜åœ¨äºå…¶ä»–åˆ—è¡¨ä¸­ï¼Œæ— æ³•æ·»åŠ ï¼š\n\n';
                    conflicts.forEach(c => {
                        message += `â€¢ ã€Œ${c.item}ã€â†’ ${c.conflicts.map(x => x.list).join('ã€')}\n`;
                    });
                    alert(message);
                    return; // é˜»æ­¢ä¿å­˜
                }

                let addedCount = 0;
                lines.forEach(line => {
                    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆåœ¨åŒä¸€ç±»å‹å†…ï¼‰
                    const exists = [...newItems].some(item => item.original === line);
                    if (!exists) {
                        newItems.add({ original: line, id: now + Math.random() });
                        addedCount++;
                    }
                });

                LISTS.customTypes.set(currentEditingType, newItems);
                saveCustomTypes();
                this.renderCustomTypesList();
                this.selectTypeForEdit(currentEditingType);

                if (addedCount > 0) {
                    console.log(`æ·»åŠ äº† ${addedCount} ä¸ªæ–°é¡¹åˆ°ç±»å‹ "${currentEditingType}"`);
                }

                // æ¸…ç©ºtextareaä¾›ä¸‹æ¬¡è¾“å…¥
                textarea.value = '';

                // è§¦å‘è”åŠ¨æ›´æ–°ï¼šé‡æ–°è¯†åˆ«æ‰€æœ‰è„±æ•é¡¹ï¼ˆåŒ…æ‹¬è‡ªå®šä¹‰ç±»å‹ï¼‰
                this.identifyRedactions();
            }

            deleteTypeItem(itemId) {
                if (!currentEditingType) return;

                const items = LISTS.customTypes.get(currentEditingType);
                if (!items) return;

                const filtered = [...items].filter(item => item.id != itemId);
                LISTS.customTypes.set(currentEditingType, new Set(filtered));
                saveCustomTypes();
                this.renderCustomTypesList();
                this.selectTypeForEdit(currentEditingType);

                // è§¦å‘è”åŠ¨æ›´æ–°ï¼šé‡æ–°è¯†åˆ«æ‰€æœ‰è„±æ•é¡¹ï¼ˆåŒ…æ‹¬è‡ªå®šä¹‰ç±»å‹ï¼‰
                this.identifyRedactions();
            }

            deleteCustomType(typeName) {
                if (!confirm('ç¡®å®šè¦åˆ é™¤ç±»å‹ "' + typeName + '" å—ï¼Ÿ\n\nè¯¥ç±»å‹ä¸‹çš„æ‰€æœ‰å†…å®¹ä¹Ÿå°†è¢«åˆ é™¤ã€‚')) return;

                LISTS.customTypes.delete(typeName);
                saveCustomTypes();

                // é‡ç½®ç¼–è¾‘åŒºåŸŸ
                document.getElementById('typeEditorArea').innerHTML = `
                    <div style="text-align:center;">
                        <div style="font-size:48px; margin-bottom:10px;">ğŸ“</div>
                        <p>â† é€‰æ‹©ä¸€ä¸ªç±»å‹å¼€å§‹ç¼–è¾‘</p>
                    </div>
                `;

                this.renderCustomTypesList();
                initTypeSelector();
            }

            /**
             * å¯¼å‡ºdocxæ–‡ä»¶ï¼ˆå¤„ç†è·¨runsæ›¿æ¢ï¼Œä¿ç•™åŸæ ¼å¼ï¼‰
             */
            async exportDocx() {
                try {
                    const arrayBuffer = await this.file.arrayBuffer();
                    const zip = await JSZip.loadAsync(arrayBuffer);

                    // è·å– document.xml
                    let xml = await zip.file("word/document.xml").async("string");

                    // è§£æXML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(xml, "text/xml");
                    const paragraphs = doc.getElementsByTagName("w:p");

                    // æŒ‰é•¿åº¦é™åºæ’åºredactionsï¼ˆé•¿æ–‡æœ¬ä¼˜å…ˆï¼‰
                    const sortedRedactions = [...this.redactions].sort((a, b) => b.original.length - a.original.length);

                    // å¤„ç†æ¯ä¸ªæ®µè½
                    for (let pIdx = 0; pIdx < paragraphs.length; pIdx++) {
                        const para = paragraphs[pIdx];
                        const runs = para.getElementsByTagName("w:r");

                        // ä½¿ç”¨é›†åˆè®°å½•å·²å¤„ç†çš„redactionç´¢å¼•
                        const processedIndices = new Set();

                        // ç­–ç•¥1ï¼šå…ˆå°è¯•å•runå†…ç®€å•æ›¿æ¢
                        for (let rIdx = 0; rIdx < sortedRedactions.length; rIdx++) {
                            const r = sortedRedactions[rIdx];
                            const original = r.original;
                            const replacement = r.replacement;
                            let found = false;

                            for (const run of runs) {
                                const textNodes = run.getElementsByTagName("w:t");
                                for (const tn of textNodes) {
                                    const text = tn.textContent;
                                    let pos = text.indexOf(original);
                                    while (pos !== -1) {
                                        // è¾¹ç•Œæ£€æŸ¥
                                        const before = pos > 0 ? text.charAt(pos - 1) : '';
                                        const after = pos + original.length < text.length ? text.charAt(pos + original.length) : '';

                                        // å‰åéƒ½ä¸èƒ½æ˜¯æ•°å­—
                                        if (!/\d/.test(before) && !/\d/.test(after)) {
                                            // æ£€æŸ¥æ˜¯å¦åœ¨ã€ã€‘å†…ï¼ˆé˜²æ­¢åµŒå¥—è„±æ•ï¼‰
                                            if (!this.isInRedactedBrackets(text, pos)) {
                                                tn.textContent = text.replace(new RegExp(this.escapeRegex(original), 'g'), replacement);
                                                found = true;
                                                break;  // å·²æ›¿æ¢ï¼Œé€€å‡ºå¾ªç¯
                                            }
                                        }
                                        pos = text.indexOf(original, pos + 1);
                                    }
                                    if (found) break;
                                }
                                if (found) break;
                            }

                            if (found) {
                                processedIndices.add(rIdx);
                            }
                        }

                        // ç­–ç•¥2ï¼šåªå¤„ç†æœªåœ¨ç­–ç•¥1ä¸­å¤„ç†çš„é¡¹
                        const unprocessedRedactions = sortedRedactions.filter((_, idx) => !processedIndices.has(idx));
                        if (unprocessedRedactions.length > 0) {
                            this.replaceAcrossRuns(para, unprocessedRedactions);
                        }
                    }

                    // åºåˆ—åŒ–XML
                    const serializer = new XMLSerializer();
                    xml = serializer.serializeToString(doc);

                    // æ›¿æ¢ XML
                    zip.file("word/document.xml", xml);

                    // ç”Ÿæˆå¹¶ä¸‹è½½æ–‡ä»¶
                    const blob = await zip.generateAsync({ type: "blob" });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement("a");
                    link.href = url;
                    link.download = this.file.name.replace(".docx", "_è„±æ•.docx");
                    link.click();
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error("å¯¼å‡ºdocxå¤±è´¥:", error);
                    alert("å¯¼å‡ºdocxå¤±è´¥: " + error.message);
                }
            }

            /**
             * å¤„ç†è·¨runsçš„æ–‡æœ¬æ›¿æ¢
             */
            replaceAcrossRuns(para, redactions) {
                const runs = para.getElementsByTagName("w:r");
                if (runs.length === 0) return;

                // ç´¯ç§¯æ‰€æœ‰runsçš„æ–‡æœ¬å’Œä½ç½®ä¿¡æ¯
                let accumulatedText = "";
                const runInfo = [];

                for (let i = 0; i < runs.length; i++) {
                    const run = runs[i];
                    const textNodes = run.getElementsByTagName("w:t");
                    let runText = "";
                    for (const tn of textNodes) {
                        runText += tn.textContent;
                    }

                    const startPos = accumulatedText.length;
                    accumulatedText += runText;
                    const endPos = accumulatedText.length;

                    runInfo.push({
                        run: run,
                        textNodes: Array.from(textNodes),
                        startPos: startPos,
                        endPos: endPos,
                        text: runText
                    });
                }

                // æŸ¥æ‰¾å¹¶æ›¿æ¢è·¨runsçš„æ–‡æœ¬
                for (const r of redactions) {
                    const original = r.original;
                    const replacement = r.replacement;

                    // åœ¨ç´¯ç§¯æ–‡æœ¬ä¸­æŸ¥æ‰¾
                    let pos = accumulatedText.indexOf(original);
                    while (pos !== -1) {
                        const endPos = pos + original.length;

                        // æ£€æŸ¥æ˜¯å¦åœ¨ã€ã€‘å†…ï¼ˆé˜²æ­¢åµŒå¥—è„±æ•ï¼‰
                        if (this.isInRedactedBrackets(accumulatedText, pos)) {
                            pos = accumulatedText.indexOf(original, endPos);
                            continue;
                        }

                        // è¾¹ç•Œæ£€æŸ¥ï¼šç¡®ä¿æ˜¯ç‹¬ç«‹çš„æ•°å­—é‡‘é¢
                        // æ£€æŸ¥å‰è¾¹ç•Œï¼šå‰é¢ä¸èƒ½æ˜¯æ•°å­—
                        if (pos > 0) {
                            const charBefore = accumulatedText.charAt(pos - 1);
                            if (/\d/.test(charBefore)) {
                                pos = accumulatedText.indexOf(original, endPos);
                                continue;
                            }
                        }

                        // æ£€æŸ¥åè¾¹ç•Œï¼šåé¢ä¸èƒ½æ˜¯æ•°å­—
                        if (endPos < accumulatedText.length) {
                            const charAfter = accumulatedText.charAt(endPos);
                            if (/\d/.test(charAfter)) {
                                pos = accumulatedText.indexOf(original, endPos);
                                continue;
                            }
                        }

                        // æ‰¾åˆ°åŒ…å«ç›®æ ‡æ–‡æœ¬çš„runs
                        const affectedRuns = [];
                        for (const info of runInfo) {
                            // æ£€æŸ¥æ­¤runæ˜¯å¦ä¸ç›®æ ‡èŒƒå›´é‡å 
                            const overlapStart = Math.max(pos, info.startPos);
                            const overlapEnd = Math.min(endPos, info.endPos);
                            if (overlapStart < overlapEnd) {
                                affectedRuns.push({
                                    info: info,
                                    overlapStart: overlapStart,
                                    overlapEnd: overlapEnd
                                });
                            }
                        }

                        if (affectedRuns.length > 0) {
                            // æ‰§è¡Œæ›¿æ¢
                            if (affectedRuns.length === 1) {
                                // å•ä¸ªrunå†…æ›¿æ¢
                                const info = affectedRuns[0].info;
                                const localStart = affectedRuns[0].overlapStart - info.startPos;
                                const localEnd = affectedRuns[0].overlapEnd - info.startPos;
                                const before = info.text.substring(0, localStart);
                                const after = info.text.substring(localEnd);
                                const newText = before + replacement + after;

                                // æ›´æ–°æ‰€æœ‰text nodes
                                let textIdx = 0;
                                for (const tn of info.textNodes) {
                                    if (textIdx === 0) {
                                        tn.textContent = newText;
                                    } else {
                                        tn.textContent = "";
                                    }
                                    textIdx++;
                                }
                            } else {
                                // è·¨å¤šä¸ªrunsæ›¿æ¢
                                const firstInfo = affectedRuns[0].info;
                                const lastInfo = affectedRuns[affectedRuns.length - 1].info;

                                const firstStart = affectedRuns[0].overlapStart - firstInfo.startPos;
                                const before = firstInfo.text.substring(0, firstStart);

                                const lastEnd = affectedRuns[affectedRuns.length - 1].overlapEnd - lastInfo.startPos;
                                const after = lastInfo.text.substring(lastEnd);

                                // ç¬¬ä¸€ä¸ªrunï¼šä¿ç•™å‰ç¼€ + æ›¿æ¢æ–‡æœ¬
                                let textIdx = 0;
                                for (const tn of firstInfo.textNodes) {
                                    if (textIdx === 0) {
                                        tn.textContent = before + replacement;
                                    } else {
                                        tn.textContent = "";
                                    }
                                    textIdx++;
                                }

                                // ä¸­é—´çš„runsï¼šæ¸…ç©º
                                for (let i = 1; i < affectedRuns.length - 1; i++) {
                                    for (const tn of affectedRuns[i].info.textNodes) {
                                        tn.textContent = "";
                                    }
                                }

                                // æœ€åä¸€ä¸ªrunï¼šä¿ç•™åç¼€
                                textIdx = 0;
                                for (const tn of lastInfo.textNodes) {
                                    if (textIdx === 0) {
                                        tn.textContent = after;
                                    } else {
                                        tn.textContent = "";
                                    }
                                    textIdx++;
                                }
                            }
                        }

                        // æŸ¥æ‰¾ä¸‹ä¸€ä¸ªåŒ¹é…
                        pos = accumulatedText.indexOf(original, endPos);
                    }
                }
            }

            /**
             * æ£€æŸ¥ä½ç½®æ˜¯å¦åœ¨ã€ã€‘æ ‡è®°å†…ï¼ˆé˜²æ­¢åµŒå¥—è„±æ•ï¼‰
             */
            isInRedactedBrackets(text, pos) {
                const beforeText = text.substring(0, pos);
                const lastOpen = beforeText.lastIndexOf('ã€');
                const lastClose = beforeText.lastIndexOf('ã€‘');
                // å¦‚æœæœ‰ã€ä½†æ²¡æœ‰ã€‘ï¼Œè¯´æ˜åœ¨ã€ã€‘å†…
                return lastOpen > lastClose;
            }

            exportMappingMD() {
                let md = `# è„±æ•å†…å®¹æ›¿æ¢æ¯”å¯¹\n\n**æ–‡ä»¶**: ${this.file.name}\n**ç”Ÿæˆæ—¶é—´**: ${new Date().toLocaleString()}\n**è„±æ•é¡¹æ€»æ•°**: ${this.redactions.length}\n\n## æ›¿æ¢æ˜ç»†\n\n| åºå· | åŸæ–‡ | æ›¿æ¢ | ç±»å‹ |\n|------|------|------|------|\n`;
                this.redactions.forEach((r, i) => {
                    // å¯¹é‚®ç®±ç±»å‹çš„åŸæ–‡è¿›è¡Œä»£ç å—åŒ…è£¹ï¼Œé˜²æ­¢markdownè‡ªåŠ¨è§£æä¸ºé“¾æ¥
                    let original = r.original;
                    if (r.type === 'email') {
                        original = `\`${original}\``;
                    }
                    // å¤„ç†è‡ªå®šä¹‰ç±»å‹çš„ç±»å‹åç§°æ˜¾ç¤º
                    const typeName = r.type.startsWith('custom-') ? r.type.replace('custom-', '') : (TYPE_NAMES[r.type] || r.type);
                    md += `| ${i+1} | ${original} | ${r.replacement} | ${typeName} |\n`;
                });

                // ä½¿ç”¨docxæ–‡ä»¶åä½œä¸ºå‰ç¼€ï¼Œä¾‹å¦‚ï¼šåˆåŒ.docx -> åˆåŒ_mapping.md
                const baseFileName = this.file.name.replace(/\.docx$/i, '');
                const mappingFileName = `${baseFileName}_mapping.md`;
                this.downloadFile(mappingFileName, md);
            }

            downloadFile(filename, content) {
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.click();
                URL.revokeObjectURL(link.href);
            }

            selectMode(mode) {
                document.getElementById('modeSelector').classList.add('hidden');
                document.getElementById('redactModeUI').classList.add('hidden');
                document.getElementById('restoreModeUI').classList.add('hidden');
                document.getElementById('redactModeCard').classList.remove('selected');
                document.getElementById('restoreModeCard').classList.remove('selected');

                if (mode === 'redact') {
                    document.getElementById('redactModeUI').classList.remove('hidden');
                    document.getElementById('redactModeCard').classList.add('selected');
                } else if (mode === 'restore') {
                    document.getElementById('restoreModeUI').classList.remove('hidden');
                    document.getElementById('restoreModeCard').classList.add('selected');
                    restoreApp.initEvents();
                }
            }

            reset() {
                document.getElementById('modeSelector').classList.remove('hidden');
                document.getElementById('redactModeUI').classList.add('hidden');
                document.getElementById('restoreModeUI').classList.add('hidden');
                document.getElementById('redactModeCard').classList.remove('selected');
                document.getElementById('restoreModeCard').classList.remove('selected');
                document.getElementById('mainContent').classList.add('hidden');
                document.getElementById('restoreResult').classList.add('hidden');
                this.file = null;
                this.document = null;
                this.redactions = [];
                this.typeCounters = {};
            }

            toggleDebug() {
                this.debugMode = document.getElementById('debugMode').checked;
                const debugPanel = document.getElementById('debugPanel');
                if (this.debugMode) {
                    debugPanel.classList.remove('hidden');
                    // é‡æ–°è¯†åˆ«ä»¥ç”Ÿæˆè°ƒè¯•æ—¥å¿—
                    if (this.document) {
                        this.identifyRedactions();
                        this.render();
                    }
                } else {
                    debugPanel.classList.add('hidden');
                }
            }

            debugLog(message) {
                if (this.debugMode) {
                    const debugLogDiv = document.getElementById('debugLog');
                    if (debugLogDiv) {
                        debugLogDiv.textContent += message + '\n';
                        debugLogDiv.scrollTop = debugLogDiv.scrollHeight;
                    }
                }
            }

            exportDebugLog() {
                const debugLogDiv = document.getElementById('debugLog');
                if (!debugLogDiv) return;

                const logContent = debugLogDiv.textContent;
                const blob = new Blob([logContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `debug_log_${new Date().getTime()}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        // è°ƒè¯•æ—¥å¿—æ”¶é›†
        const debugLogs = [];
        const originalConsoleLog = console.log;
        console.log = function(...args) {
            originalConsoleLog.apply(console, args);
            debugLogs.push(args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' '));
        };

        // å¯¼å‡ºè°ƒè¯•æ—¥å¿—
        function exportDebugLogs() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const content = debugLogs.join('\n');
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `debug-logs-${timestamp}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // è¿˜åŸåº”ç”¨ç±»
        class RestoreApp {
            constructor() {
                this.file = null;
                this.mappingFile = null;
                this.mapping = {};
            }

            initEvents() {
                // è„±æ•ç¨¿æ–‡ä»¶ä¸Šä¼ 
                const uploadArea = document.getElementById('restoreUploadArea');
                const fileInput = document.getElementById('restoreFileInput');
                uploadArea.onclick = () => fileInput.click();
                uploadArea.ondragover = (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); };
                uploadArea.ondragleave = () => uploadArea.classList.remove('dragover');
                uploadArea.ondrop = (e) => { e.preventDefault(); uploadArea.classList.remove('dragover'); if(e.dataTransfer.files[0]) this.handleFile(e.dataTransfer.files[0]); };
                fileInput.onchange = (e) => { if(e.target.files[0]) this.handleFile(e.target.files[0]); };

                // æ¯”å¯¹.mdæ–‡ä»¶ä¸Šä¼ 
                const mappingUploadArea = document.getElementById('mappingUploadArea');
                const mappingFileInput = document.getElementById('mappingFileInput');
                mappingUploadArea.onclick = () => mappingFileInput.click();
                mappingUploadArea.ondragover = (e) => { e.preventDefault(); mappingUploadArea.classList.add('dragover'); };
                mappingUploadArea.ondragleave = () => mappingUploadArea.classList.remove('dragover');
                mappingUploadArea.ondrop = (e) => { e.preventDefault(); mappingUploadArea.classList.remove('dragover'); if(e.dataTransfer.files[0]) this.handleMappingFile(e.dataTransfer.files[0]); };
                mappingFileInput.onchange = (e) => { if(e.target.files[0]) this.handleMappingFile(e.target.files[0]); };
            }

            handleFile(file) {
                if (!file.name.endsWith('.docx')) {
                    alert('è¯·ä¸Šä¼ docxæ–‡ä»¶');
                    return;
                }
                this.file = file;
                document.getElementById('restoreUploadArea').innerHTML = `
                    <div style="font-size: 48px;">âœ…</div>
                    <div style="font-size: 16px; margin-top: 10px;">å·²é€‰æ‹©ï¼š${file.name}</div>
                `;
            }

            handleMappingFile(file) {
                const validExtensions = ['.md', '.txt'];
                const hasValidExtension = validExtensions.some(ext => file.name.endsWith(ext));

                if (!hasValidExtension) {
                    alert('è¯·ä¸Šä¼ .mdæˆ–.txtæ–‡ä»¶');
                    return;
                }

                this.mappingFile = file;
                document.getElementById('mappingUploadArea').innerHTML = `
                    <div style="font-size: 48px;">âœ…</div>
                    <div style="font-size: 16px; margin-top: 10px;">å·²é€‰æ‹©ï¼š${file.name}</div>
                `;
            }

            parseMapping(content) {
                console.log('=== è°ƒè¯•ï¼šåŸå§‹æ¯”å¯¹.mdå†…å®¹ ===');
                console.log(content);
                console.log('=== è°ƒè¯•ï¼šå¼€å§‹è§£æ ===');

                const mapping = {};
                const tablePattern = /\|\s*\d+\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|/g;
                let match;

                while ((match = tablePattern.exec(content)) !== null) {
                    let original = match[1].trim();
                    const replacement = match[2].trim();

                    console.log(`è§£æåˆ°: original="${original}", replacement="${replacement}"`);

                    if (original === 'åŸæ–‡' || replacement === 'æ›¿æ¢') continue;
                    if (replacement.startsWith('ã€') && replacement.endsWith('ã€‘')) {
                        // å¤„ç†å„ç§markdowné“¾æ¥æ ¼å¼ï¼Œæå–çœŸå®çš„é‚®ç®±åœ°å€
                        // 1. ä»£ç å—æ ¼å¼: `xxx@example.com`
                        const codeBlockMatch = original.match(/^`(.+)`$/);
                        if (codeBlockMatch) {
                            original = codeBlockMatch[1];
                            console.log(`  -> ä»£ç å—æ ¼å¼ï¼Œæå–: "${original}"`);
                        }
                        // 2. markdowné“¾æ¥æ ¼å¼: [xxx@example.com](mailto:xxx@example.com)
                        else if (original.startsWith('[') && original.includes('](')) {
                            const linkTextMatch = original.match(/^\[([^\]]+)\]/);
                            if (linkTextMatch) {
                                original = linkTextMatch[1];
                                console.log(`  -> é“¾æ¥æ ¼å¼ï¼Œæå–: "${original}"`);
                            }
                        }
                        // 3. è‡ªåŠ¨é“¾æ¥æ ¼å¼: <xxx@example.com>
                        else if (original.startsWith('<') && original.endsWith('>')) {
                            original = original.slice(1, -1);
                            console.log(`  -> è‡ªåŠ¨é“¾æ¥æ ¼å¼ï¼Œæå–: "${original}"`);
                        }

                        mapping[replacement] = original;
                        console.log(`  -> æ˜ å°„: "${replacement}" => "${original}"`);
                    }
                }

                console.log('=== è°ƒè¯•ï¼šè§£æåˆ°çš„æ˜ å°„ ===');
                console.log(JSON.stringify(mapping, null, 2));
                console.log(`=== è°ƒè¯•ï¼šå…± ${Object.keys(mapping).length} æ¡æ˜ å°„ ===`);
                return mapping;
            }

            async executeRestore() {
                if (!this.file) {
                    alert('è¯·å…ˆä¸Šä¼ è„±æ•ç¨¿æ–‡ä»¶');
                    return;
                }

                if (!this.mappingFile) {
                    alert('è¯·å…ˆä¸Šä¼ æ¯”å¯¹.mdæ–‡ä»¶');
                    return;
                }

                // è¯»å–æ¯”å¯¹.mdæ–‡ä»¶å†…å®¹
                const mappingContent = await this.mappingFile.text();

                this.mapping = this.parseMapping(mappingContent);
                if (Object.keys(this.mapping).length === 0) {
                    alert('æœªèƒ½ä»æ¯”å¯¹.mdä¸­è§£æå‡ºæœ‰æ•ˆçš„æ›¿æ¢æ˜ å°„ï¼Œè¯·æ£€æŸ¥æ ¼å¼');
                    return;
                }

                try {
                    const arrayBuffer = await this.file.arrayBuffer();
                    const zip = await JSZip.loadAsync(arrayBuffer);

                    // è·å– document.xml
                    let xml = await zip.file("word/document.xml").async("string");

                    // è§£æXML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(xml, "text/xml");
                    const paras = doc.getElementsByTagName("w:p");

                    let restoreCount = 0;

                    // å¤„ç†æ¯ä¸ªæ®µè½
                    for (const para of paras) {
                        const runs = para.getElementsByTagName("w:r");
                        if (runs.length === 0) continue;

                        // ç´¯ç§¯æ‰€æœ‰runsçš„æ–‡æœ¬å’Œä½ç½®ä¿¡æ¯
                        let accumulatedText = "";
                        const runInfo = [];

                        for (let i = 0; i < runs.length; i++) {
                            const run = runs[i];
                            const textNodes = run.getElementsByTagName("w:t");
                            console.log(`æ„å»ºrun[${i}]: å‘ç° ${textNodes.length} ä¸ª textNodes`);

                            let runText = "";
                            for (let j = 0; j < textNodes.length; j++) {
                                const tn = textNodes[j];
                                const content = tn.textContent;
                                console.log(`  textNode[${j}]: é•¿åº¦=${content.length}, å†…å®¹="${content}"`);
                                runText += content;
                            }

                            const startPos = accumulatedText.length;
                            accumulatedText += runText;
                            const endPos = accumulatedText.length;

                            console.log(`æ„å»ºrun[${i}]: runTexté•¿åº¦=${runText.length}, startPos=${startPos}, endPos=${endPos}`);
                            console.log(`  runTextå®Œæ•´å†…å®¹: "${runText}"`);

                            runInfo.push({
                                run: run,
                                textNodes: Array.from(textNodes),
                                startPos: startPos,
                                endPos: endPos,
                                text: runText,
                                runInfoIndex: i
                            });
                        }

                        // è°ƒè¯•ï¼šæ˜¾ç¤ºç´¯ç§¯æ–‡æœ¬ä¿¡æ¯
                        console.log(`è°ƒè¯•ï¼šaccumulatedTexté•¿åº¦=${accumulatedText.length}, å†…å®¹="${accumulatedText.substring(0, 50)}..."`);
                        console.log(`è°ƒè¯•ï¼šrunInfoå…±${runInfo.length}ä¸ªruns`);

                        // æŸ¥æ‰¾å¹¶æ›¿æ¢æ‰€æœ‰æ ‡è®°
                        for (const [replacement, original] of Object.entries(this.mapping)) {
                            let pos = accumulatedText.indexOf(replacement);
                            if (pos !== -1) {
                                console.log(`è°ƒè¯•ï¼šåœ¨æ®µè½ä¸­æ‰¾åˆ° "${replacement}"ï¼Œä½ç½® ${pos}ï¼Œå°†æ›¿æ¢ä¸º "${original}"`);
                            }
                            while (pos !== -1) {
                                const endPos = pos + replacement.length;

                                console.log(`è°ƒè¯•ï¼šç›®æ ‡ä½ç½® pos=${pos}, endPos=${endPos}, é•¿åº¦=${replacement.length}`);

                                // æ‰¾åˆ°åŒ…å«ç›®æ ‡æ–‡æœ¬çš„runs
                                const affectedRuns = [];
                                for (const info of runInfo) {
                                    const overlapStart = Math.max(pos, info.startPos);
                                    const overlapEnd = Math.min(endPos, info.endPos);
                                    // å…³é”®ä¿®å¤ï¼šä½¿ç”¨ <= å¤„ç†è¾¹ç•Œæƒ…å†µï¼ˆå½“ç›®æ ‡ä½ç½®æ­£å¥½åœ¨runè¾¹ç•Œæ—¶ï¼‰
                                    const hasOverlap = overlapStart <= overlapEnd && overlapStart < info.endPos && overlapEnd > info.startPos;
                                    console.log(`  runInfo[${info.runInfoIndex}]: startPos=${info.startPos}, endPos=${info.endPos}, text="${info.text.substring(0, 30)}..."`);
                                    console.log(`    overlapStart=${overlapStart}, overlapEnd=${overlapEnd}, hasOverlap=${hasOverlap}`);
                                    if (hasOverlap) {
                                        affectedRuns.push({
                                            info: info,
                                            overlapStart: overlapStart,
                                            overlapEnd: overlapEnd
                                        });
                                    }
                                }

                                console.log(`è°ƒè¯•ï¼šaffectedRuns.length = ${affectedRuns.length}`);
                                if (affectedRuns.length > 0) {
                                    console.log(`è°ƒè¯•ï¼šå¼€å§‹æ›¿æ¢ï¼Œå½±å“ ${affectedRuns.length} ä¸ªruns`);

                                    if (affectedRuns.length === 1) {
                                        // åœ¨åŒä¸€ä¸ªrunå†…æ›¿æ¢
                                        const info = affectedRuns[0].info;
                                        const startOffset = affectedRuns[0].overlapStart - info.startPos;
                                        const endOffset = affectedRuns[0].overlapEnd - info.startPos;
                                        const oldContent = info.textNodes[0].textContent;
                                        const newContent = info.text.substring(0, startOffset) + original + info.text.substring(endOffset);
                                        info.textNodes[0].textContent = newContent;
                                        // å…³é”®ä¿®å¤ï¼šæ›´æ–°runInfoä¸­çš„textå­—æ®µï¼Œç¡®ä¿åç»­æ›¿æ¢ä½¿ç”¨æœ€æ–°çŠ¶æ€
                                        info.text = newContent;
                                        console.log(`  åŒrunæ›¿æ¢: "${oldContent}" -> "${newContent}"`);
                                        console.log(`  ä¿®æ”¹åtextContent: "${info.textNodes[0].textContent}"`);
                                    } else {
                                        // è·¨å¤šä¸ªrunsæ›¿æ¢
                                        console.log(`  è·¨runsæ›¿æ¢: æ¶‰åŠ ${affectedRuns.length} ä¸ªruns`);
                                        const firstInfo = affectedRuns[0].info;
                                        const lastInfo = affectedRuns[affectedRuns.length - 1].info;

                                        const firstStart = affectedRuns[0].overlapStart - firstInfo.startPos;
                                        const before = firstInfo.text.substring(0, firstStart);

                                        const lastEnd = affectedRuns[affectedRuns.length - 1].overlapEnd - lastInfo.startPos;
                                        const after = lastInfo.text.substring(lastEnd);

                                        console.log(`  before: "${before}", original: "${original}", after: "${after}"`);

                                        // ç¬¬ä¸€ä¸ªrunï¼šä¿ç•™å‰ç¼€ + åŸæ–‡
                                        let textIdx = 0;
                                        for (const tn of firstInfo.textNodes) {
                                            if (textIdx === 0) {
                                                tn.textContent = before + original;
                                                console.log(`  ç¬¬ä¸€ä¸ªrunä¿®æ”¹: "${before + original}"`);
                                            } else {
                                                tn.textContent = "";
                                            }
                                            textIdx++;
                                        }

                                        // ä¸­é—´çš„runsï¼šæ¸…ç©º
                                        for (let i = 1; i < affectedRuns.length - 1; i++) {
                                            const item = affectedRuns[i];
                                            for (const tn of item.info.textNodes) {
                                                tn.textContent = "";
                                            }
                                        }

                                        // æœ€åä¸€ä¸ªrunï¼šä¿ç•™åç¼€
                                        textIdx = 0;
                                        for (const tn of lastInfo.textNodes) {
                                            if (textIdx === 0) {
                                                tn.textContent = after;
                                                console.log(`  æœ€åä¸€ä¸ªrunä¿®æ”¹: "${after}"`);
                                            } else {
                                                tn.textContent = "";
                                            }
                                            textIdx++;
                                        }

                                        // å…³é”®ä¿®å¤ï¼šæ›´æ–°runInfoä¸­çš„textå­—æ®µï¼Œç¡®ä¿åç»­æ›¿æ¢ä½¿ç”¨æœ€æ–°çŠ¶æ€
                                        firstInfo.text = before + original;
                                        lastInfo.text = after;
                                        for (let i = 1; i < affectedRuns.length - 1; i++) {
                                            affectedRuns[i].info.text = "";
                                        }
                                        console.log(`  è·¨runsæ›¿æ¢å®Œæˆï¼Œå·²æ›´æ–°runInfo.text`);
                                    }

                                    restoreCount++;
                                    console.log(`è°ƒè¯•ï¼šæ›¿æ¢å®Œæˆï¼Œå½“å‰è®¡æ•° ${restoreCount}`);

                                    // æ›´æ–°ç´¯ç§¯æ–‡æœ¬
                                    accumulatedText = accumulatedText.substring(0, pos) + original + accumulatedText.substring(endPos);

                                    // å…³é”®ä¿®å¤ï¼šé‡æ–°æ„å»ºrunInfoä»¥ç¡®ä¿ä½ç½®ä¿¡æ¯å‡†ç¡®
                                    // å› ä¸ºæ›¿æ¢åæ–‡æœ¬é•¿åº¦å˜åŒ–ï¼Œéœ€è¦ä»textNodesé‡æ–°è¯»å–
                                    runInfo.length = 0;  // æ¸…ç©ºæ•°ç»„
                                    let newAccumulatedText = "";
                                    for (let i = 0; i < runs.length; i++) {
                                        const run = runs[i];
                                        const textNodes = run.getElementsByTagName("w:t");
                                        let runText = "";
                                        for (const tn of textNodes) {
                                            runText += tn.textContent;
                                        }

                                        const startPos = newAccumulatedText.length;
                                        newAccumulatedText += runText;
                                        const endPos = newAccumulatedText.length;

                                        runInfo.push({
                                            run: run,
                                            textNodes: Array.from(textNodes),
                                            startPos: startPos,
                                            endPos: endPos,
                                            text: runText,
                                            runInfoIndex: i
                                        });
                                    }
                                    accumulatedText = newAccumulatedText;
                                    console.log(`è°ƒè¯•ï¼šé‡æ–°æ„å»ºrunInfoå®Œæˆï¼ŒaccumulatedTexté•¿åº¦=${accumulatedText.length}`);
                                }

                                pos = accumulatedText.indexOf(replacement, endPos);
                            }
                        }
                    }

                    // åºåˆ—åŒ–XML
                    const serializer = new XMLSerializer();
                    xml = serializer.serializeToString(doc);

                    // æ›¿æ¢ XML
                    zip.file("word/document.xml", xml);

                    // ç”Ÿæˆå¹¶ä¸‹è½½æ–‡ä»¶
                    const blob = await zip.generateAsync({ type: "blob" });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement("a");
                    link.href = url;
                    link.download = this.file.name.replace(".docx", "_è¿˜åŸ.docx");
                    link.click();
                    URL.revokeObjectURL(url);

                    // æ˜¾ç¤ºç»“æœ
                    document.getElementById('restoreCount').textContent = restoreCount;
                    document.getElementById('restoreResult').classList.remove('hidden');

                } catch (error) {
                    console.error("è¿˜åŸå¤±è´¥:", error);
                    alert("è¿˜åŸå¤±è´¥: " + error.message);
                }
            }
        }

        const app = new RedactionApp();
        const restoreApp = new RestoreApp();
    </script>
</body>
</html>